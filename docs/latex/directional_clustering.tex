%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{directional\_clustering}
\date{Dec 08, 2020}
\release{0.1.0}
\author{Rafael Pastrana, Isabel Moreira, Alex Papamatthaiou, Hui Yuan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{intro:introduction}}\label{\detokenize{intro::doc}}
Directional clustering of vector fields on meshes.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{five_clusters}.png}
\end{figure}

The initial motivation of this work revolved around principal stress fields.
In principle, they suggest good directions to orient material efficiently in
architectural structures. This implies that by following these directions,
less material would be used to achieve a target level of structural performance.

Principal stress fields are ubiquitously computed by off\sphinxhyphen{}the\sphinxhyphen{}shelf FEA software
and are represented as a cloud of vectors (i.e. a vector field).

As principal stress fields are heterogeneous and form continuous curvilinear
trajectories, it is actually difficult for fabrication reasons to place material
(in the form reinforcement bars or beams) in a way that exactly match the field
directions. It is almost cumbersome, and this is probably one of the reasons why
we actually keep on building with orthogonal grids everywhere (take a look at
the room around you, for example).

In this work we question the heterogeneity of a principal stress field and
inquiry on how much we can simplify it so that we can maximize fabricability
while compromising as little as possible in structural performance. In short,
what we want is to find the lowest possible amount of different vectors that
encode the maximum amount of directional information about a principal stress
field. We leverage clustering methods to this end.


\chapter{Getting Started}
\label{\detokenize{gettingstarted:getting-started}}\label{\detokenize{gettingstarted::doc}}

\section{Installation}
\label{\detokenize{gettingstarted:installation}}
The simplest way to install \sphinxcode{\sphinxupquote{directional\_clustering}} is to build it from source
after cloning this repo. For developer mode, please jump to the next section.

1. First, we would need to install the latest version of
\sphinxhref{https://www.continuum.io/}{Anaconda}. Anaconda will take care, among many other
things, of installing scientific computing packages like \sphinxcode{\sphinxupquote{numpy}} and
\sphinxcode{\sphinxupquote{matplotlib}} for us.

2. Next, let’s create a new \sphinxcode{\sphinxupquote{conda}} environment from your command line interface
(your terminal on macOS or from the anaconda prompt on windows).
The only required dependencies are \sphinxcode{\sphinxupquote{compas}} and \sphinxcode{\sphinxupquote{sklearn}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda create \PYGZhy{}n clusters \PYG{n+nv}{python}\PYG{o}{=}\PYG{l+m}{3}.7 \PYG{n+nv}{COMPAS}\PYG{o}{=}\PYG{l+m}{0}.16.9 scikit\PYGZhy{}learn
conda activate clusters
\end{sphinxVerbatim}

3. We should clone \sphinxcode{\sphinxupquote{directional\_clustering}} from this repository and move inside.
If you are a macOS user and want to put it in your home folder:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} \PYGZti{}
git clone https://github.com/arpastrana/directional\PYGZus{}clustering.git
\PYG{n+nb}{cd} directional\PYGZus{}clustering
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
Next, install \sphinxcode{\sphinxupquote{directional\_clustering}} as an editable package from source using \sphinxcode{\sphinxupquote{pip}}:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install \PYGZhy{}e .
\end{sphinxVerbatim}

5. To double\sphinxhyphen{}check that everything is up and running, still in your command line
interface, let’s type the following and hit enter:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python \PYGZhy{}c \PYG{l+s+s2}{\PYGZdq{}import directional\PYGZus{}clustering\PYGZdq{}}
\end{sphinxVerbatim}

If no errors occur, smile :)! You have a working installation of
\sphinxcode{\sphinxupquote{directional\_clustering}}.


\section{Developer Mode}
\label{\detokenize{gettingstarted:developer-mode}}
If you are rather interested in building the documentation, testing, or making a
pull request to this package, you should install this package slighly differently.

Concretely, instead of running \sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}e .}} in step 4 above, we must do:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install \PYGZhy{}r requirements\PYGZhy{}dev.txt
\end{sphinxVerbatim}

This will take care of installing additional dependencies like \sphinxcode{\sphinxupquote{sphinx}} and \sphinxcode{\sphinxupquote{pytest}}.


\subsection{Testing}
\label{\detokenize{gettingstarted:testing}}
To run the \sphinxcode{\sphinxupquote{pytest}} suite automatically, type from the command line;

\begin{sphinxVerbatim}[commandchars=\\\{\}]
invoke \PYG{n+nb}{test}
\end{sphinxVerbatim}


\subsection{Documentation}
\label{\detokenize{gettingstarted:documentation}}
To build this package’s documentation in \sphinxcode{\sphinxupquote{html}}, type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
invoke docs
\end{sphinxVerbatim}

You’ll find the generated \sphinxcode{\sphinxupquote{html}} data in the \sphinxcode{\sphinxupquote{docs/}} folder.

If instead what we need is a manual in \sphinxcode{\sphinxupquote{pdf}} format, let’s run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
invoke pdf
\end{sphinxVerbatim}

The manual will be saved in \sphinxcode{\sphinxupquote{docs/latex}} as \sphinxcode{\sphinxupquote{directional\_clustering.pdf}}.


\chapter{API Reference}
\label{\detokenize{api:api-reference}}\label{\detokenize{api::doc}}\phantomsection\label{\detokenize{api/directional_clustering:module-directional_clustering}}\index{module@\spxentry{module}!directional\_clustering@\spxentry{directional\_clustering}}\index{directional\_clustering@\spxentry{directional\_clustering}!module@\spxentry{module}}

\section{directional\_clustering}
\label{\detokenize{api/directional_clustering:directional-clustering}}\label{\detokenize{api/directional_clustering::doc}}\phantomsection\label{\detokenize{api/directional_clustering.clustering:module-directional_clustering.clustering}}\index{module@\spxentry{module}!directional\_clustering.clustering@\spxentry{directional\_clustering.clustering}}\index{directional\_clustering.clustering@\spxentry{directional\_clustering.clustering}!module@\spxentry{module}}

\subsection{directional\_clustering.clustering}
\label{\detokenize{api/directional_clustering.clustering:directional-clustering-clustering}}\label{\detokenize{api/directional_clustering.clustering::doc}}

\subsubsection{Clustering Classes}
\label{\detokenize{api/directional_clustering.clustering:clustering-classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.KMeans:directional_clustering.clustering.KMeans}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{KMeans}}}}}
&
Generic K\sphinxhyphen{}means clustering algorithm.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.clustering.CosineKMeans:directional_clustering.clustering.CosineKMeans}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CosineKMeans}}}}}
&
K\sphinxhyphen{}means clustering using cosine distance as the association metric.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans:directional_clustering.clustering.VariationalKMeans}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{VariationalKMeans}}}}}
&
The variational shape approximation method for vector clustering.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{KMeans}
\label{\detokenize{api/generated/directional_clustering.clustering.KMeans:kmeans}}\label{\detokenize{api/generated/directional_clustering.clustering.KMeans::doc}}\index{KMeans (class in directional\_clustering.clustering)@\spxentry{KMeans}\spxextra{class in directional\_clustering.clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.KMeans:directional_clustering.clustering.KMeans}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.clustering.}}\sphinxbfcode{\sphinxupquote{KMeans}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{vector\_field}}, \emph{\DUrole{n}{n\_clusters}}, \emph{\DUrole{n}{iters}}, \emph{\DUrole{n}{tol}}}{}
Generic K\sphinxhyphen{}means clustering algorithm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxtitleref{directional\_clustering.mesh.MeshPlus}) \textendash{} A reference mesh.

\item {} 
\sphinxstylestrong{vector\_field} (\sphinxtitleref{directional\_clustering.fields.VectorField}) \textendash{} The vector field to cluster.

\item {} 
\sphinxstylestrong{n\_clusters} (\sphinxtitleref{int}) \textendash{} The number of clusters to generate.

\item {} 
\sphinxstylestrong{iters} (\sphinxtitleref{int}) \textendash{} The iterations to run the algorithm for.

\item {} 
\sphinxstylestrong{tol} (\sphinxtitleref{float}) \textendash{} The tolerance to declare convergence.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{\sphinxupquote{clustered\_field}}
&
The clustered vector field.
\\
\hline
\sphinxcode{\sphinxupquote{labels}}
&
A mapping from a vector field’s keys to the indices of the clusters centers.
\\
\hline
\sphinxcode{\sphinxupquote{loss}}
&
The total loss that k\sphinxhyphen{}means produced after clustering a vector field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Inherited Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.KMeans.__init__:directional_clustering.clustering.KMeans.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}(mesh, vector\_field, n\_clusters, …)
&
Initialize self.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.clustering.KMeans.cluster:directional_clustering.clustering.KMeans.cluster}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cluster}}}}}()
&
Cluster a vector field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{KMeans.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.clustering.KMeans.__init__:kmeans-init}}\label{\detokenize{api/generated/directional_clustering.clustering.KMeans.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.clustering.KMeans method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.clustering.KMeans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.KMeans.__init__:directional_clustering.clustering.KMeans.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{KMeans.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{vector\_field}}, \emph{\DUrole{n}{n\_clusters}}, \emph{\DUrole{n}{iters}}, \emph{\DUrole{n}{tol}}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}



\subparagraph{KMeans.cluster}
\label{\detokenize{api/generated/directional_clustering.clustering.KMeans.cluster:kmeans-cluster}}\label{\detokenize{api/generated/directional_clustering.clustering.KMeans.cluster::doc}}\index{cluster() (directional\_clustering.clustering.KMeans method)@\spxentry{cluster()}\spxextra{directional\_clustering.clustering.KMeans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.KMeans.cluster:directional_clustering.clustering.KMeans.cluster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{KMeans.}}\sphinxbfcode{\sphinxupquote{cluster}}}{}{}
Cluster a vector field.
\subsubsection*{Notes}

It sets \sphinxtitleref{self.\_clustered\_field}, \sphinxtitleref{self\_labels}, \sphinxtitleref{self.centers}, and \sphinxtitleref{self.loss}.
Returns \sphinxtitleref{None}.

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}

\end{fulllineitems}



\paragraph{CosineKMeans}
\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans:cosinekmeans}}\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans::doc}}\index{CosineKMeans (class in directional\_clustering.clustering)@\spxentry{CosineKMeans}\spxextra{class in directional\_clustering.clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans:directional_clustering.clustering.CosineKMeans}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.clustering.}}\sphinxbfcode{\sphinxupquote{CosineKMeans}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{vector\_field}}, \emph{\DUrole{n}{n\_clusters}}, \emph{\DUrole{n}{iters}}, \emph{\DUrole{n}{tol}}}{}
K\sphinxhyphen{}means clustering using cosine distance as the association metric.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxtitleref{directional\_clustering.mesh.MeshPlus}) \textendash{} A reference mesh. Reserved.

\item {} 
\sphinxstylestrong{vector\_field} (\sphinxtitleref{directional\_clustering.fields.VectorField}) \textendash{} The vector field to cluster.

\item {} 
\sphinxstylestrong{n\_clusters} (\sphinxtitleref{int}) \textendash{} The number of clusters to generate.

\item {} 
\sphinxstylestrong{iters} (\sphinxtitleref{int}) \textendash{} The iterations to run the algorithm for.

\item {} 
\sphinxstylestrong{tol} (\sphinxtitleref{float}) \textendash{} The tolerance to declare convergence.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Inherited Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{\sphinxupquote{clustered\_field}}
&
The clustered vector field.
\\
\hline
\sphinxcode{\sphinxupquote{labels}}
&
A mapping from a vector field’s keys to the indices of the clusters centers.
\\
\hline
\sphinxcode{\sphinxupquote{loss}}
&
The total loss that k\sphinxhyphen{}means produced after clustering a vector field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.CosineKMeans.__init__:directional_clustering.clustering.CosineKMeans.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}(mesh, vector\_field, n\_clusters, …)
&
Initialize self.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{CosineKMeans.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans.__init__:cosinekmeans-init}}\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.clustering.CosineKMeans method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.clustering.CosineKMeans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans.__init__:directional_clustering.clustering.CosineKMeans.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CosineKMeans.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{vector\_field}}, \emph{\DUrole{n}{n\_clusters}}, \emph{\DUrole{n}{iters}}, \emph{\DUrole{n}{tol}}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.CosineKMeans.cluster:directional_clustering.clustering.CosineKMeans.cluster}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cluster}}}}}()
&
Cluster a vector field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{CosineKMeans.cluster}
\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans.cluster:cosinekmeans-cluster}}\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans.cluster::doc}}\index{cluster() (directional\_clustering.clustering.CosineKMeans method)@\spxentry{cluster()}\spxextra{directional\_clustering.clustering.CosineKMeans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.CosineKMeans.cluster:directional_clustering.clustering.CosineKMeans.cluster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CosineKMeans.}}\sphinxbfcode{\sphinxupquote{cluster}}}{}{}
Cluster a vector field.
\subsubsection*{Notes}

It sets \sphinxtitleref{self.\_clustered\_field}, \sphinxtitleref{self\_labels}, \sphinxtitleref{self.centers}, and \sphinxtitleref{self.loss}.
Returns \sphinxtitleref{None}.

\end{fulllineitems}


\end{fulllineitems}



\paragraph{VariationalKMeans}
\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans:variationalkmeans}}\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans::doc}}\index{VariationalKMeans (class in directional\_clustering.clustering)@\spxentry{VariationalKMeans}\spxextra{class in directional\_clustering.clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans:directional_clustering.clustering.VariationalKMeans}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.clustering.}}\sphinxbfcode{\sphinxupquote{VariationalKMeans}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{vector\_field}}, \emph{\DUrole{n}{n\_clusters}}, \emph{\DUrole{n}{iters}}, \emph{\DUrole{n}{tol}}}{}
The variational shape approximation method for vector clustering.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxtitleref{directional\_clustering.mesh.MeshPlus}) \textendash{} A reference mesh.

\item {} 
\sphinxstylestrong{vector\_field} (\sphinxtitleref{directional\_clustering.fields.VectorField}) \textendash{} The vector field to cluster.

\item {} 
\sphinxstylestrong{n\_clusters} (\sphinxtitleref{int}) \textendash{} The number of clusters to generate.

\item {} 
\sphinxstylestrong{iters} (\sphinxtitleref{int}) \textendash{} The iterations to run the algorithm for.

\item {} 
\sphinxstylestrong{tol} (\sphinxtitleref{float}) \textendash{} The tolerance to declare convergence.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

This method normalizes all vectors before doing clustering.
\subsubsection*{References}

{[}1{]} Cohen\sphinxhyphen{}Steiner, D., Alliez, P., Desbrun, M. (2004). Variational Shape Approximation.
RR\sphinxhyphen{}5371, INRIA. 2004, pp.29. inria\sphinxhyphen{}00070632
\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Inherited Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{\sphinxupquote{clustered\_field}}
&
The clustered vector field.
\\
\hline
\sphinxcode{\sphinxupquote{labels}}
&
A mapping from a vector field’s keys to the indices of the clusters centers.
\\
\hline
\sphinxcode{\sphinxupquote{loss}}
&
The total loss that k\sphinxhyphen{}means produced after clustering a vector field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans.__init__:directional_clustering.clustering.VariationalKMeans.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}(mesh, vector\_field, n\_clusters, …)
&
Initialize self.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans.cluster:directional_clustering.clustering.VariationalKMeans.cluster}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cluster}}}}}()
&
Cluster a vector field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{VariationalKMeans.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans.__init__:variationalkmeans-init}}\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.clustering.VariationalKMeans method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.clustering.VariationalKMeans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans.__init__:directional_clustering.clustering.VariationalKMeans.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VariationalKMeans.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{vector\_field}}, \emph{\DUrole{n}{n\_clusters}}, \emph{\DUrole{n}{iters}}, \emph{\DUrole{n}{tol}}}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}



\subparagraph{VariationalKMeans.cluster}
\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans.cluster:variationalkmeans-cluster}}\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans.cluster::doc}}\index{cluster() (directional\_clustering.clustering.VariationalKMeans method)@\spxentry{cluster()}\spxextra{directional\_clustering.clustering.VariationalKMeans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.VariationalKMeans.cluster:directional_clustering.clustering.VariationalKMeans.cluster}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VariationalKMeans.}}\sphinxbfcode{\sphinxupquote{cluster}}}{}{}
Cluster a vector field.
\subsubsection*{Notes}

It sets \sphinxtitleref{self.\_clustered\_field}, \sphinxtitleref{self\_labels}, \sphinxtitleref{self.centers}, and \sphinxtitleref{self.loss}.
Returns \sphinxtitleref{None}.

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}

\end{fulllineitems}



\subsubsection{Factory Classes}
\label{\detokenize{api/directional_clustering.clustering:factory-classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory:directional_clustering.clustering.ClusteringFactory}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ClusteringFactory}}}}}
&
A factory to unify the creation of clustering algorithms.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{ClusteringFactory}
\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory:clusteringfactory}}\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory::doc}}\index{ClusteringFactory (class in directional\_clustering.clustering)@\spxentry{ClusteringFactory}\spxextra{class in directional\_clustering.clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory:directional_clustering.clustering.ClusteringFactory}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.clustering.}}\sphinxbfcode{\sphinxupquote{ClusteringFactory}}}
A factory to unify the creation of clustering algorithms.
\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{\sphinxupquote{supported\_algorithms}}
&

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Inherited Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.create:directional_clustering.clustering.ClusteringFactory.create}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{create}}}}}(name)
&
Creates an unitialized clustering algorithm.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.register:directional_clustering.clustering.ClusteringFactory.register}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{register}}}}}(name, algorithm)
&
Registers a clustering algorithm to the factory’s database.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{ClusteringFactory.create}
\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.create:clusteringfactory-create}}\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.create::doc}}\index{create() (directional\_clustering.clustering.ClusteringFactory class method)@\spxentry{create()}\spxextra{directional\_clustering.clustering.ClusteringFactory class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.create:directional_clustering.clustering.ClusteringFactory.create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{ClusteringFactory.}}\sphinxbfcode{\sphinxupquote{create}}}{\emph{\DUrole{n}{name}}}{}
Creates an unitialized clustering algorithm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{name} (\sphinxtitleref{str}) \textendash{} The name of the clustering algorithm to generate.

\item[{Returns}] \leavevmode
\sphinxstylestrong{algorithm} (\sphinxtitleref{directional\_clustering.clustering.ClusteringAlgorithm}) \textendash{} A clustering algorithm to instantiate.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{ClusteringFactory.register}
\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.register:clusteringfactory-register}}\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.register::doc}}\index{register() (directional\_clustering.clustering.ClusteringFactory class method)@\spxentry{register()}\spxextra{directional\_clustering.clustering.ClusteringFactory class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.register:directional_clustering.clustering.ClusteringFactory.register}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{ClusteringFactory.}}\sphinxbfcode{\sphinxupquote{register}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{algorithm}}}{}
Registers a clustering algorithm to the factory’s database.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{name} (\sphinxtitleref{str}) \textendash{} The name key by which a clustering will be stored.

\item {} 
\sphinxstylestrong{algorithm} (\sphinxtitleref{directional\_clustering.clustering.ClusteringAlgorithm}) \textendash{} A clustering algorithm.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.__init__:directional_clustering.clustering.ClusteringFactory.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
Initialize self.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{ClusteringFactory.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.__init__:clusteringfactory-init}}\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.clustering.ClusteringFactory method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.clustering.ClusteringFactory method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringFactory.__init__:directional_clustering.clustering.ClusteringFactory.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ClusteringFactory.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Abstract Classes}
\label{\detokenize{api/directional_clustering.clustering:abstract-classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm:directional_clustering.clustering.ClusteringAlgorithm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ClusteringAlgorithm}}}}}
&
Abstract base class for all clustering algorithms.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{ClusteringAlgorithm}
\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm:clusteringalgorithm}}\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm::doc}}\index{ClusteringAlgorithm (class in directional\_clustering.clustering)@\spxentry{ClusteringAlgorithm}\spxextra{class in directional\_clustering.clustering}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm:directional_clustering.clustering.ClusteringAlgorithm}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.clustering.}}\sphinxbfcode{\sphinxupquote{ClusteringAlgorithm}}}
Abstract base class for all clustering algorithms.
\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{\sphinxupquote{clustered\_field}}
&
The clustered vector field.
\\
\hline
\sphinxcode{\sphinxupquote{labels}}
&
The labels that reference entries in the vector field to clusters.
\\
\hline
\sphinxcode{\sphinxupquote{loss}}
&
The final error of the produced by the clustering method.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Inherited Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm.cluster:directional_clustering.clustering.ClusteringAlgorithm.cluster}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cluster}}}}}(*args, **kwargs)
&
Main clustering method.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{ClusteringAlgorithm.cluster}
\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm.cluster:clusteringalgorithm-cluster}}\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm.cluster::doc}}\index{cluster() (directional\_clustering.clustering.ClusteringAlgorithm method)@\spxentry{cluster()}\spxextra{directional\_clustering.clustering.ClusteringAlgorithm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm.cluster:directional_clustering.clustering.ClusteringAlgorithm.cluster}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxcode{\sphinxupquote{ClusteringAlgorithm.}}\sphinxbfcode{\sphinxupquote{cluster}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Main clustering method.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{args} (\sphinxtitleref{list}, optional) \textendash{} Default arguments.

\item {} 
\sphinxstylestrong{kwargs} (\sphinxtitleref{dict}, optional) \textendash{} Default keyword arguments.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm.__init__:directional_clustering.clustering.ClusteringAlgorithm.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
Initialize self.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{ClusteringAlgorithm.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm.__init__:clusteringalgorithm-init}}\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.clustering.ClusteringAlgorithm method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.clustering.ClusteringAlgorithm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.clustering.ClusteringAlgorithm.__init__:directional_clustering.clustering.ClusteringAlgorithm.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ClusteringAlgorithm.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{api/directional_clustering.fields:module-directional_clustering.fields}}\index{module@\spxentry{module}!directional\_clustering.fields@\spxentry{directional\_clustering.fields}}\index{directional\_clustering.fields@\spxentry{directional\_clustering.fields}!module@\spxentry{module}}

\subsection{directional\_clustering.fields}
\label{\detokenize{api/directional_clustering.fields:directional-clustering-fields}}\label{\detokenize{api/directional_clustering.fields::doc}}

\subsubsection{Fields}
\label{\detokenize{api/directional_clustering.fields:fields}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.fields.Field:directional_clustering.fields.Field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Field}}}}}
&
A concrete field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField:directional_clustering.fields.VectorField}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{VectorField}}}}}
&
A field with a fixed dimensionality of 3.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{Field}
\label{\detokenize{api/generated/directional_clustering.fields.Field:field}}\label{\detokenize{api/generated/directional_clustering.fields.Field::doc}}\index{Field (class in directional\_clustering.fields)@\spxentry{Field}\spxextra{class in directional\_clustering.fields}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.Field:directional_clustering.fields.Field}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.fields.}}\sphinxbfcode{\sphinxupquote{Field}}}{\emph{\DUrole{n}{dimensionality}}}{}
A concrete field.

Basically, a container for scalars and vectors.
One key can store exclusively one value at a time.

It is crucial to have it as a datastructure where a field’s entries
are accessed with the keys of the Mesh they are coupled to.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{dimensionality} (\sphinxtitleref{int}) \textendash{} The dimensionality of the field.

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.fields.Field.__init__:directional_clustering.fields.Field.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}(dimensionality)
&
The constructor.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.Field.dimensionality:directional_clustering.fields.Field.dimensionality}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dimensionality}}}}}()
&
The fixed dimensionality of a field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.Field.size:directional_clustering.fields.Field.size}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{size}}}}}()
&
The number of items stored in the field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{Field.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.fields.Field.__init__:field-init}}\label{\detokenize{api/generated/directional_clustering.fields.Field.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.fields.Field method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.fields.Field method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.Field.__init__:directional_clustering.fields.Field.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Field.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{dimensionality}}}{}
The constructor.

\end{fulllineitems}



\subparagraph{Field.dimensionality}
\label{\detokenize{api/generated/directional_clustering.fields.Field.dimensionality:field-dimensionality}}\label{\detokenize{api/generated/directional_clustering.fields.Field.dimensionality::doc}}\index{dimensionality() (directional\_clustering.fields.Field method)@\spxentry{dimensionality()}\spxextra{directional\_clustering.fields.Field method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.Field.dimensionality:directional_clustering.fields.Field.dimensionality}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Field.}}\sphinxbfcode{\sphinxupquote{dimensionality}}}{}{}
The fixed dimensionality of a field.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{dimensionality} (\sphinxtitleref{int}) \textendash{} The dimensionality of the field.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{Field.size}
\label{\detokenize{api/generated/directional_clustering.fields.Field.size:field-size}}\label{\detokenize{api/generated/directional_clustering.fields.Field.size::doc}}\index{size() (directional\_clustering.fields.Field method)@\spxentry{size()}\spxextra{directional\_clustering.fields.Field method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.Field.size:directional_clustering.fields.Field.size}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Field.}}\sphinxbfcode{\sphinxupquote{size}}}{}{}
The number of items stored in the field.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{size} (\sphinxtitleref{int}) \textendash{} The number of items.

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}

\end{fulllineitems}



\paragraph{VectorField}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField:vectorfield}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField::doc}}\index{VectorField (class in directional\_clustering.fields)@\spxentry{VectorField}\spxextra{class in directional\_clustering.fields}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField:directional_clustering.fields.VectorField}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.fields.}}\sphinxbfcode{\sphinxupquote{VectorField}}}
A field with a fixed dimensionality of 3.
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.__init__:directional_clustering.fields.VectorField.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
The constructor.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.add_vector:directional_clustering.fields.VectorField.add_vector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_vector}}}}}(key, vector)
&
Adds a vector entry to a vector field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.from_mesh_faces:directional_clustering.fields.VectorField.from_mesh_faces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_mesh\_faces}}}}}(mesh, name)
&
Extracts a vector field from the faces of a mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.from_sequence:directional_clustering.fields.VectorField.from_sequence}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_sequence}}}}}(sequence)
&
Creates a vector field from a sequence.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.items:directional_clustering.fields.VectorField.items}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{items}}}}}()
&
Iterates over the keys and the vectors of the field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.keys:directional_clustering.fields.VectorField.keys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{keys}}}}}()
&
Iterates over they access keys of the vector field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.remove_vector:directional_clustering.fields.VectorField.remove_vector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{remove\_vector}}}}}(key)
&
Deletes a vector from the vector field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.to_sequence:directional_clustering.fields.VectorField.to_sequence}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_sequence}}}}}()
&
Converts a vector field into a sequence.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.vector:directional_clustering.fields.VectorField.vector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vector}}}}}(key)
&
Queries a vector from a vector field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.vectors:directional_clustering.fields.VectorField.vectors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vectors}}}}}()
&
Iterates over the vectors of the vector field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{VectorField.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.__init__:vectorfield-init}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.fields.VectorField method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.__init__:directional_clustering.fields.VectorField.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}
The constructor.

\end{fulllineitems}



\subparagraph{VectorField.add\_vector}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.add_vector:vectorfield-add-vector}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.add_vector::doc}}\index{add\_vector() (directional\_clustering.fields.VectorField method)@\spxentry{add\_vector()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.add_vector:directional_clustering.fields.VectorField.add_vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{add\_vector}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{vector}}}{}
Adds a vector entry to a vector field.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxtitleref{int}) \textendash{} The key to store the vector with.

\item {} 
\sphinxstylestrong{vector} (\sphinxtitleref{list} of \sphinxtitleref{float}) \textendash{} A vector in 3d space.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{VectorField.from\_mesh\_faces}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.from_mesh_faces:vectorfield-from-mesh-faces}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.from_mesh_faces::doc}}\index{from\_mesh\_faces() (directional\_clustering.fields.VectorField class method)@\spxentry{from\_mesh\_faces()}\spxextra{directional\_clustering.fields.VectorField class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.from_mesh_faces:directional_clustering.fields.VectorField.from_mesh_faces}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{from\_mesh\_faces}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{name}}}{}
Extracts a vector field from the faces of a mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxtitleref{directional\_clustering.mesh.MeshPlus}) \textendash{} A mesh.

\item {} 
\sphinxstylestrong{name} (\sphinxtitleref{str}) \textendash{} The name of the face attribute to query.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{vector\_field} (\sphinxtitleref{VectorField}) \textendash{} A vector field.

\end{description}\end{quote}
\subsubsection*{Notes}

Deprecated.
Every vector is stored with the mesh face keys as access keys.

\end{fulllineitems}



\subparagraph{VectorField.from\_sequence}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.from_sequence:vectorfield-from-sequence}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.from_sequence::doc}}\index{from\_sequence() (directional\_clustering.fields.VectorField class method)@\spxentry{from\_sequence()}\spxextra{directional\_clustering.fields.VectorField class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.from_sequence:directional_clustering.fields.VectorField.from_sequence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{from\_sequence}}}{\emph{\DUrole{n}{sequence}}}{}
Creates a vector field from a sequence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{sequence} (\sphinxtitleref{list} of \sphinxtitleref{list}) \textendash{} A list of vectors.

\item[{Returns}] \leavevmode
\sphinxstylestrong{vector\_field} (\sphinxtitleref{directional\_clustering.fields.VectorField}) \textendash{} A vector field.

\end{description}\end{quote}
\subsubsection*{Notes}

The vectors are stored in the order they are supplied.
Access keys are generated in the range from 0 to the sequence length.

\end{fulllineitems}



\subparagraph{VectorField.items}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.items:vectorfield-items}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.items::doc}}\index{items() (directional\_clustering.fields.VectorField method)@\spxentry{items()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.items:directional_clustering.fields.VectorField.items}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{items}}}{}{}
Iterates over the keys and the vectors of the field.
\begin{quote}\begin{description}
\item[{Yields}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxtitleref{int}) \textendash{} The next access key in the vector field.

\item {} 
\sphinxstylestrong{vector} (\sphinxtitleref{list} of \sphinxtitleref{float}) \textendash{} The next vector in the vector field.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{VectorField.keys}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.keys:vectorfield-keys}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.keys::doc}}\index{keys() (directional\_clustering.fields.VectorField method)@\spxentry{keys()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.keys:directional_clustering.fields.VectorField.keys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{keys}}}{}{}
Iterates over they access keys of the vector field.
\begin{quote}\begin{description}
\item[{Yields}] \leavevmode
\sphinxstylestrong{key} (\sphinxtitleref{int}) \textendash{} The next access key in the vector field.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{VectorField.remove\_vector}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.remove_vector:vectorfield-remove-vector}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.remove_vector::doc}}\index{remove\_vector() (directional\_clustering.fields.VectorField method)@\spxentry{remove\_vector()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.remove_vector:directional_clustering.fields.VectorField.remove_vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{remove\_vector}}}{\emph{\DUrole{n}{key}}}{}
Deletes a vector from the vector field.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxtitleref{int}) \textendash{} The key of the vector to remove.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{VectorField.to\_sequence}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.to_sequence:vectorfield-to-sequence}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.to_sequence::doc}}\index{to\_sequence() (directional\_clustering.fields.VectorField method)@\spxentry{to\_sequence()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.to_sequence:directional_clustering.fields.VectorField.to_sequence}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{to\_sequence}}}{}{}
Converts a vector field into a sequence.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{sequence} (\sphinxtitleref{list} of \sphinxtitleref{list}) \textendash{} A list of vectors.

\end{description}\end{quote}
\subsubsection*{Notes}

The output vectors are not sorted by their access keys.

\end{fulllineitems}



\subparagraph{VectorField.vector}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.vector:vectorfield-vector}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.vector::doc}}\index{vector() (directional\_clustering.fields.VectorField method)@\spxentry{vector()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.vector:directional_clustering.fields.VectorField.vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{vector}}}{\emph{\DUrole{n}{key}}}{}
Queries a vector from a vector field.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxtitleref{int}) \textendash{} The key of the vector to retrieve.

\item[{Returns}] \leavevmode
\sphinxstylestrong{vector} (\sphinxtitleref{list} of \sphinxtitleref{float}) \textendash{} A vector.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{VectorField.vectors}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.vectors:vectorfield-vectors}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.vectors::doc}}\index{vectors() (directional\_clustering.fields.VectorField method)@\spxentry{vectors()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.vectors:directional_clustering.fields.VectorField.vectors}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{vectors}}}{}{}
Iterates over the vectors of the vector field.
\begin{quote}\begin{description}
\item[{Yields}] \leavevmode
\sphinxstylestrong{vector} (\sphinxtitleref{list} of \sphinxtitleref{float}) \textendash{} The next vector in the vector field.

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.dimensionality:directional_clustering.fields.VectorField.dimensionality}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dimensionality}}}}}()
&
The fixed dimensionality of a field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.VectorField.size:directional_clustering.fields.VectorField.size}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{size}}}}}()
&
The number of items stored in the field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{VectorField.dimensionality}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.dimensionality:vectorfield-dimensionality}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.dimensionality::doc}}\index{dimensionality() (directional\_clustering.fields.VectorField method)@\spxentry{dimensionality()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.dimensionality:directional_clustering.fields.VectorField.dimensionality}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{dimensionality}}}{}{}
The fixed dimensionality of a field.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{dimensionality} (\sphinxtitleref{int}) \textendash{} The dimensionality of the field.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{VectorField.size}
\label{\detokenize{api/generated/directional_clustering.fields.VectorField.size:vectorfield-size}}\label{\detokenize{api/generated/directional_clustering.fields.VectorField.size::doc}}\index{size() (directional\_clustering.fields.VectorField method)@\spxentry{size()}\spxextra{directional\_clustering.fields.VectorField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.VectorField.size:directional_clustering.fields.VectorField.size}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{VectorField.}}\sphinxbfcode{\sphinxupquote{size}}}{}{}
The number of items stored in the field.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{size} (\sphinxtitleref{int}) \textendash{} The number of items.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsubsection{Abstract Classes}
\label{\detokenize{api/directional_clustering.fields:abstract-classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.fields.AbstractField:directional_clustering.fields.AbstractField}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{AbstractField}}}}}
&
An abstract class for all fields.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{AbstractField}
\label{\detokenize{api/generated/directional_clustering.fields.AbstractField:abstractfield}}\label{\detokenize{api/generated/directional_clustering.fields.AbstractField::doc}}\index{AbstractField (class in directional\_clustering.fields)@\spxentry{AbstractField}\spxextra{class in directional\_clustering.fields}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.AbstractField:directional_clustering.fields.AbstractField}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.fields.}}\sphinxbfcode{\sphinxupquote{AbstractField}}}
An abstract class for all fields.
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.fields.AbstractField.dimensionality:directional_clustering.fields.AbstractField.dimensionality}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dimensionality}}}}}()
&
The fixed dimensionality of a field.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.fields.AbstractField.size:directional_clustering.fields.AbstractField.size}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{size}}}}}()
&
The number of entries in the field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{AbstractField.dimensionality}
\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.dimensionality:abstractfield-dimensionality}}\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.dimensionality::doc}}\index{dimensionality() (directional\_clustering.fields.AbstractField method)@\spxentry{dimensionality()}\spxextra{directional\_clustering.fields.AbstractField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.dimensionality:directional_clustering.fields.AbstractField.dimensionality}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxcode{\sphinxupquote{AbstractField.}}\sphinxbfcode{\sphinxupquote{dimensionality}}}{}{}
The fixed dimensionality of a field.

\end{fulllineitems}



\subparagraph{AbstractField.size}
\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.size:abstractfield-size}}\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.size::doc}}\index{size() (directional\_clustering.fields.AbstractField method)@\spxentry{size()}\spxextra{directional\_clustering.fields.AbstractField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.size:directional_clustering.fields.AbstractField.size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxcode{\sphinxupquote{AbstractField.}}\sphinxbfcode{\sphinxupquote{size}}}{}{}
The number of entries in the field.

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.fields.AbstractField.__init__:directional_clustering.fields.AbstractField.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
Initialize self.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{AbstractField.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.__init__:abstractfield-init}}\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.fields.AbstractField method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.fields.AbstractField method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.fields.AbstractField.__init__:directional_clustering.fields.AbstractField.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{AbstractField.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{api/directional_clustering.mesh:module-directional_clustering.mesh}}\index{module@\spxentry{module}!directional\_clustering.mesh@\spxentry{directional\_clustering.mesh}}\index{directional\_clustering.mesh@\spxentry{directional\_clustering.mesh}!module@\spxentry{module}}

\subsection{directional\_clustering.mesh}
\label{\detokenize{api/directional_clustering.mesh:directional-clustering-mesh}}\label{\detokenize{api/directional_clustering.mesh::doc}}

\subsubsection{Classes}
\label{\detokenize{api/directional_clustering.mesh:classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus:directional_clustering.mesh.MeshPlus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshPlus}}}}}
&
An extended COMPAS mesh with specialized methods to parse vector fields.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{MeshPlus}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus:meshplus}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus::doc}}\index{MeshPlus (class in directional\_clustering.mesh)@\spxentry{MeshPlus}\spxextra{class in directional\_clustering.mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus:directional_clustering.mesh.MeshPlus}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{directional\_clustering.mesh.}}\sphinxbfcode{\sphinxupquote{MeshPlus}}}
An extended COMPAS mesh with specialized methods to parse vector fields.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{args} (\sphinxtitleref{list}, optional.) \textendash{} Default arguments.

\item {} 
\sphinxstylestrong{kwargs} (\sphinxtitleref{dict}, optional.) \textendash{} Default keyword arguments.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

See \sphinxtitleref{help(compas.datastructures.Mesh)} for details on the constructor’s signature.
\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Inherited Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{\sphinxupquote{DATASCHEMA}}
&
The schema of the data of this object.
\\
\hline
\sphinxcode{\sphinxupquote{JSONSCHEMA}}
&
The schema of the JSON representation of the data of this object.
\\
\hline
\sphinxcode{\sphinxupquote{adjacency}}
&

\\
\hline
\sphinxcode{\sphinxupquote{data}}
&
A data dict representing the mesh data structure for serialisation.
\\
\hline
\sphinxcode{\sphinxupquote{dtype}}
&
str: The type of the object in the form of a “2\sphinxhyphen{}level” import and a class name.
\\
\hline
\sphinxcode{\sphinxupquote{guid}}
&
The globally unique identifier of the object.
\\
\hline
\sphinxcode{\sphinxupquote{name}}
&
The name of the data structure.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.clustering_label:directional_clustering.mesh.MeshPlus.clustering_label}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{clustering\_label}}}}}(name{[}, labels{]})
&
Gets or sets cluster labels on a mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vector_field:directional_clustering.mesh.MeshPlus.vector_field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vector\_field}}}}}(name{[}, vector\_field{]})
&
Gets or sets a vector field that lives on the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vector_fields:directional_clustering.mesh.MeshPlus.vector_fields}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vector\_fields}}}}}()
&
Queries the names of all the vector fields stored on the mesh.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{MeshPlus.clustering\_label}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.clustering_label:meshplus-clustering-label}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.clustering_label::doc}}\index{clustering\_label() (directional\_clustering.mesh.MeshPlus method)@\spxentry{clustering\_label()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.clustering_label:directional_clustering.mesh.MeshPlus.clustering_label}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{clustering\_label}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{labels}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Gets or sets cluster labels on a mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{name} (\sphinxtitleref{str}) \textendash{} The name of the cluster label.
The format is \{vector\_field\_name\}\_\{algorithm\}\_\{number\_of\_clusters\}.

\item {} 
\sphinxstylestrong{labels} (\sphinxtitleref{dict}, optional.) \textendash{} The cluster labels to store. Defaults to \sphinxtitleref{None}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{labels} (\sphinxtitleref{dict}) \textendash{} The fetched labels only if a \sphinxtitleref{name} was input.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vector\_field}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vector_field:meshplus-vector-field}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vector_field::doc}}\index{vector\_field() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vector\_field()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vector_field:directional_clustering.mesh.MeshPlus.vector_field}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vector\_field}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{vector\_field}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Gets or sets a vector field that lives on the mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{name} (\sphinxtitleref{str}) \textendash{} The name of the vector field to get or to set.

\item {} 
\sphinxstylestrong{vector\_field} (\sphinxtitleref{directional\_clustering.fields.VectorField}, optional.) \textendash{} The vector field to store. Defaults to \sphinxtitleref{None}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{vector\_field} (\sphinxtitleref{directional\_clustering.fields.VectorField}.) \textendash{} The fetched vector field if a \sphinxtitleref{name} was input.

\end{description}\end{quote}
\subsubsection*{Notes}

Vector fields are stored a face attributes of a mesh.
Refer to \sphinxtitleref{compas.datastructures.face\_attribute()} for more details.

\end{fulllineitems}



\subparagraph{MeshPlus.vector\_fields}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vector_fields:meshplus-vector-fields}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vector_fields::doc}}\index{vector\_fields() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vector\_fields()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vector_fields:directional_clustering.mesh.MeshPlus.vector_fields}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vector\_fields}}}{}{}
Queries the names of all the vector fields stored on the mesh.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{attr\_vectorfield} (\sphinxtitleref{list}) \textendash{} A list of with the vector field names.

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Inherited Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.__init__:directional_clustering.mesh.MeshPlus.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}()
&
Initialize self.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.add_face:directional_clustering.mesh.MeshPlus.add_face}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_face}}}}}(vertices{[}, fkey, attr\_dict{]})
&
Add a face to the mesh object.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.add_vertex:directional_clustering.mesh.MeshPlus.add_vertex}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_vertex}}}}}({[}key, attr\_dict{]})
&
Add a vertex to the mesh object.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.area:directional_clustering.mesh.MeshPlus.area}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{area}}}}}()
&
Calculate the total mesh area.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.bounding_box:directional_clustering.mesh.MeshPlus.bounding_box}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bounding\_box}}}}}()
&
Compute the (axis aligned) bounding box of a mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.bounding_box_xy:directional_clustering.mesh.MeshPlus.bounding_box_xy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bounding\_box\_xy}}}}}()
&
Compute the (axis aligned) bounding box of a projection of the mesh in the XY plane.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.centroid:directional_clustering.mesh.MeshPlus.centroid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{centroid}}}}}()
&
Calculate the mesh centroid.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.clear:directional_clustering.mesh.MeshPlus.clear}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{clear}}}}}()
&
Clear all the mesh data.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.collapse_edge:directional_clustering.mesh.MeshPlus.collapse_edge}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{collapse\_edge}}}}}(u, v{[}, t, allow\_boundary, fixed{]})
&
Collapse an edge to its first or second vertex, or to an intermediate point.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.connected_components:directional_clustering.mesh.MeshPlus.connected_components}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{connected\_components}}}}}()
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.copy:directional_clustering.mesh.MeshPlus.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}({[}cls{]})
&
Make an independent copy of the datastructure object.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cull_vertices:directional_clustering.mesh.MeshPlus.cull_vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cull\_vertices}}}}}()
&
Remove all unused vertices from the mesh object.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cut:directional_clustering.mesh.MeshPlus.cut}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cut}}}}}(plane)
&
Cut a mesh with a plane and construct the resulting submeshes.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.delete_face:directional_clustering.mesh.MeshPlus.delete_face}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{delete\_face}}}}}(fkey)
&
Delete a face from the mesh object.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.delete_vertex:directional_clustering.mesh.MeshPlus.delete_vertex}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{delete\_vertex}}}}}(key)
&
Delete a vertex from the mesh and everything that is attached to it.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.dual:directional_clustering.mesh.MeshPlus.dual}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dual}}}}}({[}cls{]})
&
Construct the dual of a mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_attribute:directional_clustering.mesh.MeshPlus.edge_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_attribute}}}}}(edge, name{[}, value{]})
&
Get or set an attribute of an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_attributes:directional_clustering.mesh.MeshPlus.edge_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_attributes}}}}}(edge{[}, names, values{]})
&
Get or set multiple attributes of an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_coordinates:directional_clustering.mesh.MeshPlus.edge_coordinates}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_coordinates}}}}}(u, v{[}, axes{]})
&
Return the coordinates of the start and end point of an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_direction:directional_clustering.mesh.MeshPlus.edge_direction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_direction}}}}}(u, v)
&
Return the direction vector of an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_faces:directional_clustering.mesh.MeshPlus.edge_faces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_faces}}}}}(u, v)
&
Find the two faces adjacent to an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_length:directional_clustering.mesh.MeshPlus.edge_length}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_length}}}}}(u, v)
&
Return the length of an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_loop:directional_clustering.mesh.MeshPlus.edge_loop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_loop}}}}}(edge)
&
Find all edges on the same loop as a given edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_midpoint:directional_clustering.mesh.MeshPlus.edge_midpoint}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_midpoint}}}}}(u, v)
&
Return the location of the midpoint of an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_point:directional_clustering.mesh.MeshPlus.edge_point}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_point}}}}}(u, v{[}, t{]})
&
Return the location of a point along an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_strip:directional_clustering.mesh.MeshPlus.edge_strip}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_strip}}}}}(edge)
&
Find all edges on the same strip as a given edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_vector:directional_clustering.mesh.MeshPlus.edge_vector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edge\_vector}}}}}(u, v)
&
Return the vector of an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges:directional_clustering.mesh.MeshPlus.edges}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edges}}}}}({[}data{]})
&
Iterate over the edges of the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_attribute:directional_clustering.mesh.MeshPlus.edges_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edges\_attribute}}}}}(name{[}, value, keys{]})
&
Get or set an attribute of multiple edges.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_attributes:directional_clustering.mesh.MeshPlus.edges_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edges\_attributes}}}}}({[}names, values, keys{]})
&
Get or set multiple attributes of multiple edges.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_on_boundaries:directional_clustering.mesh.MeshPlus.edges_on_boundaries}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edges\_on\_boundaries}}}}}()
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_on_boundary:directional_clustering.mesh.MeshPlus.edges_on_boundary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edges\_on\_boundary}}}}}({[}oriented{]})
&
Find the edges on the boundary.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_where:directional_clustering.mesh.MeshPlus.edges_where}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edges\_where}}}}}(conditions{[}, data{]})
&
Get edges for which a certain condition or set of conditions is true.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_where_predicate:directional_clustering.mesh.MeshPlus.edges_where_predicate}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{edges\_where\_predicate}}}}}(predicate{[}, data{]})
&
Get edges for which a certain condition or set of conditions is true using a lambda function.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.euler:directional_clustering.mesh.MeshPlus.euler}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{euler}}}}}()
&
Calculate the Euler characteristic.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency:directional_clustering.mesh.MeshPlus.face_adjacency}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_adjacency}}}}}()
&
Build a face adjacency dict.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency_halfedge:directional_clustering.mesh.MeshPlus.face_adjacency_halfedge}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_adjacency\_halfedge}}}}}(f1, f2)
&
Find one half\sphinxhyphen{}edge over which two faces are adjacent.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency_vertices:directional_clustering.mesh.MeshPlus.face_adjacency_vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_adjacency\_vertices}}}}}(f1, f2)
&
Find all vertices over which two faces are adjacent.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_area:directional_clustering.mesh.MeshPlus.face_area}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_area}}}}}(fkey)
&
Compute the area of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_aspect_ratio:directional_clustering.mesh.MeshPlus.face_aspect_ratio}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_aspect\_ratio}}}}}(fkey)
&
Face aspect ratio as the ratio between the lengths of the maximum and minimum face edges.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_attribute:directional_clustering.mesh.MeshPlus.face_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_attribute}}}}}(key, name{[}, value{]})
&
Get or set an attribute of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_attributes:directional_clustering.mesh.MeshPlus.face_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_attributes}}}}}(key{[}, names, values{]})
&
Get or set multiple attributes of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_center:directional_clustering.mesh.MeshPlus.face_center}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_center}}}}}(fkey)
&
Compute the location of the center of mass of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_centroid:directional_clustering.mesh.MeshPlus.face_centroid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_centroid}}}}}(fkey)
&
Compute the location of the centroid of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_coordinates:directional_clustering.mesh.MeshPlus.face_coordinates}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_coordinates}}}}}(fkey{[}, axes{]})
&
Compute the coordinates of the vertices of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_corners:directional_clustering.mesh.MeshPlus.face_corners}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_corners}}}}}(fkey)
&
Return triplets of face vertices forming the corners of the face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_curvature:directional_clustering.mesh.MeshPlus.face_curvature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_curvature}}}}}(fkey)
&
Dimensionless face curvature as the maximum face vertex deviation from the best\sphinxhyphen{}fit plane of the face vertices divided by the average lengths of the face vertices to the face centroid.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_degree:directional_clustering.mesh.MeshPlus.face_degree}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_degree}}}}}(fkey)
&
Count the neighbors of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_flatness:directional_clustering.mesh.MeshPlus.face_flatness}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_flatness}}}}}(fkey{[}, maxdev{]})
&
Compute the flatness of the mesh face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_halfedges:directional_clustering.mesh.MeshPlus.face_halfedges}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_halfedges}}}}}(fkey)
&
The halfedges of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_max_degree:directional_clustering.mesh.MeshPlus.face_max_degree}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_max\_degree}}}}}()
&
Compute the maximum degree of all faces.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_min_degree:directional_clustering.mesh.MeshPlus.face_min_degree}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_min\_degree}}}}}()
&
Compute the minimum degree of all faces.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_neighborhood:directional_clustering.mesh.MeshPlus.face_neighborhood}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_neighborhood}}}}}(key{[}, ring{]})
&
Return the faces in the neighborhood of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_neighbors:directional_clustering.mesh.MeshPlus.face_neighbors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_neighbors}}}}}(fkey)
&
Return the neighbors of a face across its edges.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_normal:directional_clustering.mesh.MeshPlus.face_normal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_normal}}}}}(fkey{[}, unitized{]})
&
Compute the normal of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_plane:directional_clustering.mesh.MeshPlus.face_plane}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_plane}}}}}(face)
&
A plane defined by the centroid and the normal of the face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_skewness:directional_clustering.mesh.MeshPlus.face_skewness}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_skewness}}}}}(fkey)
&
Face skewness as the maximum absolute angular deviation from the ideal polygon angle.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertex_ancestor:directional_clustering.mesh.MeshPlus.face_vertex_ancestor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_vertex\_ancestor}}}}}(fkey, key{[}, n{]})
&
Return the n\sphinxhyphen{}th vertex before the specified vertex in a specific face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertex_descendant:directional_clustering.mesh.MeshPlus.face_vertex_descendant}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_vertex\_descendant}}}}}(fkey, key{[}, n{]})
&
Return the n\sphinxhyphen{}th vertex after the specified vertex in a specific face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertices:directional_clustering.mesh.MeshPlus.face_vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{face\_vertices}}}}}(fkey)
&
The vertices of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces:directional_clustering.mesh.MeshPlus.faces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{faces}}}}}({[}data{]})
&
Iterate over the faces of the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_attribute:directional_clustering.mesh.MeshPlus.faces_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{faces\_attribute}}}}}(name{[}, value, keys{]})
&
Get or set an attribute of multiple faces.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_attributes:directional_clustering.mesh.MeshPlus.faces_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{faces\_attributes}}}}}({[}names, values, keys{]})
&
Get or set multiple attributes of multiple faces.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_on_boundary:directional_clustering.mesh.MeshPlus.faces_on_boundary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{faces\_on\_boundary}}}}}()
&
Find the faces on the boundary.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_where:directional_clustering.mesh.MeshPlus.faces_where}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{faces\_where}}}}}(conditions{[}, data{]})
&
Get faces for which a certain condition or set of conditions is true.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_where_predicate:directional_clustering.mesh.MeshPlus.faces_where_predicate}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{faces\_where\_predicate}}}}}(predicate{[}, data{]})
&
Get faces for which a certain condition or set of conditions is true using a lambda function.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.flip_cycles:directional_clustering.mesh.MeshPlus.flip_cycles}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{flip\_cycles}}}}}()
&
Flip the cycle directions of all faces.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_data:directional_clustering.mesh.MeshPlus.from_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_data}}}}}(data)
&
Construct a datastructure from structured data.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_json:directional_clustering.mesh.MeshPlus.from_json}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_json}}}}}(filepath)
&
Construct a datastructure from structured data contained in a json file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_lines:directional_clustering.mesh.MeshPlus.from_lines}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_lines}}}}}(lines{[}, delete\_boundary\_face, …{]})
&
Construct a mesh object from a list of lines described by start and end point coordinates.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_obj:directional_clustering.mesh.MeshPlus.from_obj}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_obj}}}}}(filepath{[}, precision{]})
&
Construct a mesh object from the data described in an OBJ file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_off:directional_clustering.mesh.MeshPlus.from_off}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_off}}}}}(filepath)
&
Construct a mesh object from the data described in a OFF file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_ply:directional_clustering.mesh.MeshPlus.from_ply}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_ply}}}}}(filepath{[}, precision{]})
&
Construct a mesh object from the data described in a PLY file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_points:directional_clustering.mesh.MeshPlus.from_points}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_points}}}}}(points{[}, boundary, holes{]})
&
Construct a mesh from a delaunay triangulation of a set of points.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polygons:directional_clustering.mesh.MeshPlus.from_polygons}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_polygons}}}}}(polygons{[}, precision{]})
&
Construct a mesh from a series of polygons.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polyhedron:directional_clustering.mesh.MeshPlus.from_polyhedron}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_polyhedron}}}}}(f)
&
Construct a mesh from a platonic solid.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polylines:directional_clustering.mesh.MeshPlus.from_polylines}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_polylines}}}}}(boundary\_polylines, …)
&
Construct mesh from polylines.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_shape:directional_clustering.mesh.MeshPlus.from_shape}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_shape}}}}}(shape, **kwargs)
&
Construct a mesh from a primitive shape.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_stl:directional_clustering.mesh.MeshPlus.from_stl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_stl}}}}}(filepath{[}, precision{]})
&
Construct a mesh object from the data described in a STL file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_vertices_and_faces:directional_clustering.mesh.MeshPlus.from_vertices_and_faces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_vertices\_and\_faces}}}}}(vertices, faces)
&
Construct a mesh object from a list of vertices and faces.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.genus:directional_clustering.mesh.MeshPlus.genus}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{genus}}}}}()
&
Calculate the genus.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_face:directional_clustering.mesh.MeshPlus.get_any_face}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_any\_face}}}}}()
&
Get the identifier of a random face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_face_vertex:directional_clustering.mesh.MeshPlus.get_any_face_vertex}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_any\_face\_vertex}}}}}(fkey)
&
Get the identifier of a random vertex of a specific face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_vertex:directional_clustering.mesh.MeshPlus.get_any_vertex}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_any\_vertex}}}}}()
&
Get the identifier of a random vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_vertices:directional_clustering.mesh.MeshPlus.get_any_vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_any\_vertices}}}}}(n{[}, exclude\_leaves{]})
&
Get a list of identifiers of a random set of n vertices.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.gkey_key:directional_clustering.mesh.MeshPlus.gkey_key}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gkey\_key}}}}}({[}precision{]})
&
Returns a dictionary that maps \sphinxstyleemphasis{geometric keys} of a certain precision to the keys of the corresponding vertices.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.halfedge_face:directional_clustering.mesh.MeshPlus.halfedge_face}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{halfedge\_face}}}}}(u, v)
&
Find the face corresponding to a halfedge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_edge:directional_clustering.mesh.MeshPlus.has_edge}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{has\_edge}}}}}(key)
&
Verify that the mesh contains a specific edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_face:directional_clustering.mesh.MeshPlus.has_face}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{has\_face}}}}}(fkey)
&
Verify that a face is part of the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_halfedge:directional_clustering.mesh.MeshPlus.has_halfedge}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{has\_halfedge}}}}}(key)
&
Verify that a halfedge is part of the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_vertex:directional_clustering.mesh.MeshPlus.has_vertex}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{has\_vertex}}}}}(key)
&
Verify that a vertex is in the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.index_key:directional_clustering.mesh.MeshPlus.index_key}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{index\_key}}}}}()
&
Returns a dictionary that maps the indices of a vertex list to keys in a vertex dictionary.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.index_vertex:directional_clustering.mesh.MeshPlus.index_vertex}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{index\_vertex}}}}}()
&
Returns a dictionary that maps the indices of a vertex list to keys in a vertex dictionary.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.insert_vertex:directional_clustering.mesh.MeshPlus.insert_vertex}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{insert\_vertex}}}}}(fkey{[}, key, xyz, return\_fkeys{]})
&
Insert a vertex in the specified face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_connected:directional_clustering.mesh.MeshPlus.is_connected}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_connected}}}}}()
&
Verify that the mesh is connected.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_edge_on_boundary:directional_clustering.mesh.MeshPlus.is_edge_on_boundary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_edge\_on\_boundary}}}}}(u, v)
&
Verify that an edge is on the boundary.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_empty:directional_clustering.mesh.MeshPlus.is_empty}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_empty}}}}}()
&
Boolean whether the mesh is empty.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_face_on_boundary:directional_clustering.mesh.MeshPlus.is_face_on_boundary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_face\_on\_boundary}}}}}(key)
&
Verify that a face is on a boundary.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_manifold:directional_clustering.mesh.MeshPlus.is_manifold}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_manifold}}}}}()
&
Verify that the mesh is manifold.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_orientable:directional_clustering.mesh.MeshPlus.is_orientable}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_orientable}}}}}()
&
Verify that the mesh is orientable.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_quadmesh:directional_clustering.mesh.MeshPlus.is_quadmesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_quadmesh}}}}}()
&
Verify that the mesh consists of only quads.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_regular:directional_clustering.mesh.MeshPlus.is_regular}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_regular}}}}}()
&
Verify that the mesh is regular.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_trimesh:directional_clustering.mesh.MeshPlus.is_trimesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_trimesh}}}}}()
&
Verify that the mesh consists of only triangles.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_valid:directional_clustering.mesh.MeshPlus.is_valid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_valid}}}}}()
&
Verify that the mesh is valid.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_vertex_connected:directional_clustering.mesh.MeshPlus.is_vertex_connected}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_vertex\_connected}}}}}(key)
&
Verify that a vertex is connected.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_vertex_on_boundary:directional_clustering.mesh.MeshPlus.is_vertex_on_boundary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_vertex\_on\_boundary}}}}}(key)
&
Verify that a vertex is on a boundary.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.join:directional_clustering.mesh.MeshPlus.join}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{join}}}}}(other)
&
Add the vertices and faces of another mesh to the current mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.key_gkey:directional_clustering.mesh.MeshPlus.key_gkey}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{key\_gkey}}}}}({[}precision{]})
&
Returns a dictionary that maps vertex dictionary keys to the corresponding \sphinxstyleemphasis{geometric key} up to a certain precision.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.key_index:directional_clustering.mesh.MeshPlus.key_index}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{key\_index}}}}}()
&
Returns a dictionary that maps vertex dictionary keys to the corresponding index in a vertex list or array.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.normal:directional_clustering.mesh.MeshPlus.normal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{normal}}}}}()
&
Calculate the average mesh normal.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_edges:directional_clustering.mesh.MeshPlus.number_of_edges}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{number\_of\_edges}}}}}()
&
Count the number of edges in the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_faces:directional_clustering.mesh.MeshPlus.number_of_faces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{number\_of\_faces}}}}}()
&
Count the number of faces in the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_vertices:directional_clustering.mesh.MeshPlus.number_of_vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{number\_of\_vertices}}}}}()
&
Count the number of vertices in the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.quads_to_triangles:directional_clustering.mesh.MeshPlus.quads_to_triangles}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{quads\_to\_triangles}}}}}({[}check\_angles{]})
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.remove_unused_vertices:directional_clustering.mesh.MeshPlus.remove_unused_vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{remove\_unused\_vertices}}}}}()
&
Remove all unused vertices from the mesh object.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.smooth_area:directional_clustering.mesh.MeshPlus.smooth_area}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{smooth\_area}}}}}({[}fixed, kmax, damping, …{]})
&
Smooth a mesh by moving each vertex to the barycenter of the centroids of the surrounding faces, weighted by area.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.smooth_centroid:directional_clustering.mesh.MeshPlus.smooth_centroid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{smooth\_centroid}}}}}({[}fixed, kmax, damping, …{]})
&
Smooth a mesh by moving every free vertex to the centroid of its neighbors.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.split_edge:directional_clustering.mesh.MeshPlus.split_edge}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{split\_edge}}}}}(u, v{[}, t, allow\_boundary{]})
&
Split and edge by inserting a vertex along its length.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.split_face:directional_clustering.mesh.MeshPlus.split_face}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{split\_face}}}}}(fkey, u, v)
&
Split a face by inserting an edge between two specified vertices.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.summary:directional_clustering.mesh.MeshPlus.summary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{summary}}}}}()
&
Print a summary of the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_data:directional_clustering.mesh.MeshPlus.to_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_data}}}}}()
&
Returns a dictionary of structured data representing the data structure.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_json:directional_clustering.mesh.MeshPlus.to_json}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_json}}}}}(filepath{[}, pretty{]})
&
Serialise the structured data representing the datastructure to json.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_lines:directional_clustering.mesh.MeshPlus.to_lines}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_lines}}}}}(filepath)
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_obj:directional_clustering.mesh.MeshPlus.to_obj}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_obj}}}}}(filepath{[}, precision, unweld{]})
&
Write the mesh to an OBJ file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_off:directional_clustering.mesh.MeshPlus.to_off}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_off}}}}}(filepath, **kwargs)
&
Write a mesh object to an OFF file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_ply:directional_clustering.mesh.MeshPlus.to_ply}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_ply}}}}}(filepath, **kwargs)
&
Write a mesh object to a PLY file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_points:directional_clustering.mesh.MeshPlus.to_points}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_points}}}}}()
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_polygons:directional_clustering.mesh.MeshPlus.to_polygons}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_polygons}}}}}()
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_polylines:directional_clustering.mesh.MeshPlus.to_polylines}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_polylines}}}}}()
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_quadmesh:directional_clustering.mesh.MeshPlus.to_quadmesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_quadmesh}}}}}()
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_stl:directional_clustering.mesh.MeshPlus.to_stl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_stl}}}}}(filepath{[}, precision, binary{]})
&
Write a mesh to an STL file.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_trimesh:directional_clustering.mesh.MeshPlus.to_trimesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_trimesh}}}}}()
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_vertices_and_faces:directional_clustering.mesh.MeshPlus.to_vertices_and_faces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{to\_vertices\_and\_faces}}}}}()
&
Return the vertices and faces of a mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transform:directional_clustering.mesh.MeshPlus.transform}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{transform}}}}}(transformation)
&
Transform a mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transform_numpy:directional_clustering.mesh.MeshPlus.transform_numpy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{transform\_numpy}}}}}(M)
&

\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transformed:directional_clustering.mesh.MeshPlus.transformed}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{transformed}}}}}(transformation)
&
Transform a copy of \sphinxcode{\sphinxupquote{mesh}}.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unify_cycles:directional_clustering.mesh.MeshPlus.unify_cycles}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unify\_cycles}}}}}({[}root{]})
&
Unify the cycle directions of all faces.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_edge_attribute:directional_clustering.mesh.MeshPlus.unset_edge_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unset\_edge\_attribute}}}}}(edge, name)
&
Unset the attribute of an edge.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_face_attribute:directional_clustering.mesh.MeshPlus.unset_face_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unset\_face\_attribute}}}}}(key, name)
&
Unset the attribute of a face.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_vertex_attribute:directional_clustering.mesh.MeshPlus.unset_vertex_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unset\_vertex\_attribute}}}}}(key, name)
&
Unset the attribute of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_edge_attributes:directional_clustering.mesh.MeshPlus.update_default_edge_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update\_default\_edge\_attributes}}}}}({[}attr\_dict{]})
&
Update the default edge attributes.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_face_attributes:directional_clustering.mesh.MeshPlus.update_default_face_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update\_default\_face\_attributes}}}}}({[}attr\_dict{]})
&
Update the default face attributes.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_vertex_attributes:directional_clustering.mesh.MeshPlus.update_default_vertex_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update\_default\_vertex\_attributes}}}}}({[}attr\_dict{]})
&
Update the default vertex attributes.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.validate_data:directional_clustering.mesh.MeshPlus.validate_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{validate\_data}}}}}()
&
Validate the data of this object against its data schema (\sphinxtitleref{self.DATASCHEMA}).
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.validate_json:directional_clustering.mesh.MeshPlus.validate_json}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{validate\_json}}}}}()
&
Validate the data loaded from a JSON representation of the data of this object against its data schema (\sphinxtitleref{self.DATASCHEMA}).
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_area:directional_clustering.mesh.MeshPlus.vertex_area}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_area}}}}}(key)
&
Compute the tributary area of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_attribute:directional_clustering.mesh.MeshPlus.vertex_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_attribute}}}}}(key, name{[}, value{]})
&
Get or set an attribute of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_attributes:directional_clustering.mesh.MeshPlus.vertex_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_attributes}}}}}(key{[}, names, values{]})
&
Get or set multiple attributes of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_coordinates:directional_clustering.mesh.MeshPlus.vertex_coordinates}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_coordinates}}}}}(key{[}, axes{]})
&
Return the coordinates of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_curvature:directional_clustering.mesh.MeshPlus.vertex_curvature}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_curvature}}}}}(vkey)
&
Dimensionless vertex curvature.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_degree:directional_clustering.mesh.MeshPlus.vertex_degree}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_degree}}}}}(key)
&
Count the neighbors of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_faces:directional_clustering.mesh.MeshPlus.vertex_faces}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_faces}}}}}(key{[}, ordered, include\_none{]})
&
The faces connected to a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_index:directional_clustering.mesh.MeshPlus.vertex_index}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_index}}}}}()
&
Returns a dictionary that maps vertex dictionary keys to the corresponding index in a vertex list or array.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_laplacian:directional_clustering.mesh.MeshPlus.vertex_laplacian}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_laplacian}}}}}(key)
&
Compute the vector from a vertex to the centroid of its neighbors.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_max_degree:directional_clustering.mesh.MeshPlus.vertex_max_degree}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_max\_degree}}}}}()
&
Compute the maximum degree of all vertices.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_min_degree:directional_clustering.mesh.MeshPlus.vertex_min_degree}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_min\_degree}}}}}()
&
Compute the minimum degree of all vertices.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighborhood:directional_clustering.mesh.MeshPlus.vertex_neighborhood}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_neighborhood}}}}}(key{[}, ring{]})
&
Return the vertices in the neighborhood of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighborhood_centroid:directional_clustering.mesh.MeshPlus.vertex_neighborhood_centroid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_neighborhood\_centroid}}}}}(key)
&
Compute the centroid of the neighbors of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighbors:directional_clustering.mesh.MeshPlus.vertex_neighbors}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_neighbors}}}}}(key{[}, ordered{]})
&
Return the neighbors of a vertex.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_normal:directional_clustering.mesh.MeshPlus.vertex_normal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertex\_normal}}}}}(key)
&
Return the normal vector at the vertex as the weighted average of the normals of the neighboring faces.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices:directional_clustering.mesh.MeshPlus.vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertices}}}}}({[}data{]})
&
Iterate over the vertices of the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_attribute:directional_clustering.mesh.MeshPlus.vertices_attribute}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertices\_attribute}}}}}(name{[}, value, keys{]})
&
Get or set an attribute of multiple vertices.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_attributes:directional_clustering.mesh.MeshPlus.vertices_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertices\_attributes}}}}}({[}names, values, keys{]})
&
Get or set multiple attributes of multiple vertices.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_on_boundaries:directional_clustering.mesh.MeshPlus.vertices_on_boundaries}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertices\_on\_boundaries}}}}}()
&
Find the vertices on all boundaries of the mesh.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_on_boundary:directional_clustering.mesh.MeshPlus.vertices_on_boundary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertices\_on\_boundary}}}}}({[}ordered{]})
&
Find the vertices on the boundary.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_where:directional_clustering.mesh.MeshPlus.vertices_where}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertices\_where}}}}}(conditions{[}, data{]})
&
Get vertices for which a certain condition or set of conditions is true.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_where_predicate:directional_clustering.mesh.MeshPlus.vertices_where_predicate}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vertices\_where\_predicate}}}}}(predicate{[}, data{]})
&
Get vertices for which a certain condition or set of conditions is true using a lambda function.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{MeshPlus.\_\_init\_\_}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.__init__:meshplus-init}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.__init__::doc}}\index{\_\_init\_\_() (directional\_clustering.mesh.MeshPlus method)@\spxentry{\_\_init\_\_()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.__init__:directional_clustering.mesh.MeshPlus.__init__}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}
Initialize self.  See help(type(self)) for accurate signature.

\end{fulllineitems}



\subparagraph{MeshPlus.add\_face}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.add_face:meshplus-add-face}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.add_face::doc}}\index{add\_face() (directional\_clustering.mesh.MeshPlus method)@\spxentry{add\_face()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.add_face:directional_clustering.mesh.MeshPlus.add_face}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{add\_face}}}{\emph{\DUrole{n}{vertices}}, \emph{\DUrole{n}{fkey}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{attr\_dict}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwattr}}}{}
Add a face to the mesh object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{vertices} (\sphinxstyleemphasis{list}) \textendash{} A list of vertex keys.

\item {} 
\sphinxstylestrong{attr\_dict} (\sphinxstyleemphasis{dict, optional}) \textendash{} Face attributes.

\item {} 
\sphinxstylestrong{kwattr} (\sphinxstyleemphasis{dict, optional}) \textendash{} Additional named face attributes.
Named face attributes overwrite corresponding attributes in the
attribute dict (\sphinxcode{\sphinxupquote{attr\_dict}}).

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The key of the face.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{TypeError}} \textendash{} If the provided face key is of an unhashable type.

\end{description}\end{quote}
\subsubsection*{Notes}

If no key is provided for the face, one is generated
automatically. An automatically generated key is an integer that increments
the highest integer value of any key used so far by 1.

If a key with an integer value is provided that is higher than the current
highest integer key value, then the highest integer value is updated accordingly.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.add\_vertex}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.add_vertex:meshplus-add-vertex}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.add_vertex::doc}}\index{add\_vertex() (directional\_clustering.mesh.MeshPlus method)@\spxentry{add\_vertex()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.add_vertex:directional_clustering.mesh.MeshPlus.add_vertex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{add\_vertex}}}{\emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{attr\_dict}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwattr}}}{}
Add a vertex to the mesh object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int, optional}) \textendash{} The vertex identifier.

\item {} 
\sphinxstylestrong{attr\_dict} (\sphinxstyleemphasis{dict, optional}) \textendash{} Vertex attributes.

\item {} 
\sphinxstylestrong{kwattr} (\sphinxstyleemphasis{dict, optional}) \textendash{} Additional named vertex attributes.
Named vertex attributes overwrite corresponding attributes in the
attribute dict (\sphinxcode{\sphinxupquote{attr\_dict}}).

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The identifier of the vertex.

\end{description}\end{quote}
\subsubsection*{Notes}

If no key is provided for the vertex, one is generated
automatically. An automatically generated key is an integer that increments
the highest integer value of any key used so far by 1.

If a key with an integer value is provided that is higher than the current
highest integer key value, then the highest integer value is updated accordingly.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{add\PYGZus{}vertex}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{add\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{z}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{add\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{key}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{add\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{key}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{0}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.area}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.area:meshplus-area}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.area::doc}}\index{area() (directional\_clustering.mesh.MeshPlus method)@\spxentry{area()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.area:directional_clustering.mesh.MeshPlus.area}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{area}}}{}{}
Calculate the total mesh area.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The area.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.bounding\_box}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.bounding_box:meshplus-bounding-box}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.bounding_box::doc}}\index{bounding\_box() (directional\_clustering.mesh.MeshPlus method)@\spxentry{bounding\_box()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.bounding_box:directional_clustering.mesh.MeshPlus.bounding_box}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{bounding\_box}}}{}{}
Compute the (axis aligned) bounding box of a mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} The mesh data structure.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list of point} \textendash{} The 8 corners of the bounding box of the mesh.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh\PYGZus{}bounding\PYGZus{}box}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{)}
\PYG{g+go}{[[0.0, 0.0, 0.0], [10.0, 0.0, 0.0], [10.0, 10.0, 0.0], [0.0, 10.0, 0.0], [0.0, 0.0, 0.0], [10.0, 0.0, 0.0], [10.0, 10.0, 0.0], [0.0, 10.0, 0.0]]}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.bounding\_box\_xy}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.bounding_box_xy:meshplus-bounding-box-xy}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.bounding_box_xy::doc}}\index{bounding\_box\_xy() (directional\_clustering.mesh.MeshPlus method)@\spxentry{bounding\_box\_xy()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.bounding_box_xy:directional_clustering.mesh.MeshPlus.bounding_box_xy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{bounding\_box\_xy}}}{}{}
Compute the (axis aligned) bounding box of a projection of the mesh in the XY plane.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} The mesh data structure.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list of point} \textendash{} The 4 corners of the bounding polygon in the XY plane.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh\PYGZus{}bounding\PYGZus{}box\PYGZus{}xy}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{)}
\PYG{g+go}{[[0.0, 0.0, 0.0], [10.0, 0.0, 0.0], [10.0, 10.0, 0.0], [0.0, 10.0, 0.0]]}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.centroid}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.centroid:meshplus-centroid}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.centroid::doc}}\index{centroid() (directional\_clustering.mesh.MeshPlus method)@\spxentry{centroid()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.centroid:directional_clustering.mesh.MeshPlus.centroid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{centroid}}}{}{}
Calculate the mesh centroid.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The coordinates of the mesh centroid.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.clear}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.clear:meshplus-clear}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.clear::doc}}\index{clear() (directional\_clustering.mesh.MeshPlus method)@\spxentry{clear()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.clear:directional_clustering.mesh.MeshPlus.clear}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{clear}}}{}{}
Clear all the mesh data.

\end{fulllineitems}



\subparagraph{MeshPlus.collapse\_edge}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.collapse_edge:meshplus-collapse-edge}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.collapse_edge::doc}}\index{collapse\_edge() (directional\_clustering.mesh.MeshPlus method)@\spxentry{collapse\_edge()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.collapse_edge:directional_clustering.mesh.MeshPlus.collapse_edge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{collapse\_edge}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}, \emph{\DUrole{n}{t}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{allow\_boundary}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{fixed}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Collapse an edge to its first or second vertex, or to an intermediate point.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} Instance of a mesh.

\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{str}) \textendash{} The first vertex of the (half\sphinxhyphen{}) edge.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{str}) \textendash{} The second vertex of the (half\sphinxhyphen{}) edge.

\item {} 
\sphinxstylestrong{t} (\sphinxstyleemphasis{float (0.5)}) \textendash{} Determines where to collapse to.
If \sphinxtitleref{t == 0.0} collapse to \sphinxtitleref{u}.
If \sphinxtitleref{t == 1.0} collapse to \sphinxtitleref{v}.
If \sphinxtitleref{0.0 \textless{} t \textless{} 1.0}, collapse to a point between \sphinxtitleref{u} and \sphinxtitleref{v}.

\item {} 
\sphinxstylestrong{allow\_boundary} (\sphinxstyleemphasis{bool (False)}) \textendash{} Allow collapses involving boundary vertices.

\item {} 
\sphinxstylestrong{fixed} (\sphinxstyleemphasis{list (None)}) \textendash{} A list of identifiers of vertices that should stay fixed.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If \sphinxtitleref{u} and \sphinxtitleref{v} are not neighbors.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.connected\_components}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.connected_components:meshplus-connected-components}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.connected_components::doc}}\index{connected\_components() (directional\_clustering.mesh.MeshPlus method)@\spxentry{connected\_components()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.connected_components:directional_clustering.mesh.MeshPlus.connected_components}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{connected\_components}}}{}{}
\end{fulllineitems}



\subparagraph{MeshPlus.copy}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.copy:meshplus-copy}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.copy::doc}}\index{copy() (directional\_clustering.mesh.MeshPlus method)@\spxentry{copy()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.copy:directional_clustering.mesh.MeshPlus.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{copy}}}{\emph{\DUrole{n}{cls}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Make an independent copy of the datastructure object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{cls} (\sphinxcode{\sphinxupquote{compas.datastructure.Datastructure}}, optional) \textendash{} The type of datastructure to return.
Defaults to the type of the current datastructure.

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{compas.datastructure.Datastructure}} \textendash{} A separate, but identical datastructure object.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.cull\_vertices}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cull_vertices:meshplus-cull-vertices}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cull_vertices::doc}}\index{cull\_vertices() (directional\_clustering.mesh.MeshPlus method)@\spxentry{cull\_vertices()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cull_vertices:directional_clustering.mesh.MeshPlus.cull_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{cull\_vertices}}}{}{}
Remove all unused vertices from the mesh object.

\end{fulllineitems}



\subparagraph{MeshPlus.cut}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cut:meshplus-cut}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cut::doc}}\index{cut() (directional\_clustering.mesh.MeshPlus method)@\spxentry{cut()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cut:directional_clustering.mesh.MeshPlus.cut}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{cut}}}{\emph{\DUrole{n}{plane}}}{}
Cut a mesh with a plane and construct the resulting submeshes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} The original mesh.

\item {} 
\sphinxstylestrong{plane} (\sphinxstyleemphasis{compas.geometry.Plane}) \textendash{} The cutting plane.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None or tuple of compas.datastructures.Mesh} \textendash{} If the mesh and plane do not intersect,
or if the intersection is degenerate (point or line),
the function returns \sphinxcode{\sphinxupquote{None}}.
Otherwise, the “positive” and “negative” submeshes are returned.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{compas}\PYG{n+nn}{.}\PYG{n+nn}{geometry} \PYG{k+kn}{import} \PYG{n}{Plane}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{compas}\PYG{n+nn}{.}\PYG{n+nn}{geometry} \PYG{k+kn}{import} \PYG{n}{Box}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{compas}\PYG{n+nn}{.}\PYG{n+nn}{datastructures} \PYG{k+kn}{import} \PYG{n}{Mesh}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plane} \PYG{o}{=} \PYG{n}{Plane}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{box} \PYG{o}{=} \PYG{n}{Box}\PYG{o}{.}\PYG{n}{from\PYGZus{}width\PYGZus{}height\PYGZus{}depth}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{Mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}shape}\PYG{p}{(}\PYG{n}{box}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{mesh\PYGZus{}cut\PYGZus{}by\PYGZus{}plane}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{,} \PYG{n}{plane}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{2}
\PYG{g+go}{True}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.delete\_face}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.delete_face:meshplus-delete-face}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.delete_face::doc}}\index{delete\_face() (directional\_clustering.mesh.MeshPlus method)@\spxentry{delete\_face()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.delete_face:directional_clustering.mesh.MeshPlus.delete_face}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{delete\_face}}}{\emph{\DUrole{n}{fkey}}}{}
Delete a face from the mesh object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\end{description}\end{quote}
\subsubsection*{Notes}

In some cases, disconnected vertices can remain after application of this
method. To remove these vertices as well, combine this method with vertex
culling ({\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cull_vertices:directional_clustering.mesh.MeshPlus.cull_vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cull\_vertices()}}}}}).
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.delete\_vertex}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.delete_vertex:meshplus-delete-vertex}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.delete_vertex::doc}}\index{delete\_vertex() (directional\_clustering.mesh.MeshPlus method)@\spxentry{delete\_vertex()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.delete_vertex:directional_clustering.mesh.MeshPlus.delete_vertex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{delete\_vertex}}}{\emph{\DUrole{n}{key}}}{}
Delete a vertex from the mesh and everything that is attached to it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\end{description}\end{quote}
\subsubsection*{Notes}

In some cases, disconnected vertices can remain after application of this
method. To remove these vertices as well, combine this method with vertex
culling ({\hyperref[\detokenize{api/generated/directional_clustering.mesh.MeshPlus.cull_vertices:directional_clustering.mesh.MeshPlus.cull_vertices}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{cull\_vertices()}}}}}).
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.dual}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.dual:meshplus-dual}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.dual::doc}}\index{dual() (directional\_clustering.mesh.MeshPlus method)@\spxentry{dual()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.dual:directional_clustering.mesh.MeshPlus.dual}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{dual}}}{\emph{\DUrole{n}{cls}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Construct the dual of a mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{Mesh}) \textendash{} A mesh object.

\item {} 
\sphinxstylestrong{cls} (\sphinxstyleemphasis{Mesh, optional {[}None{]}}) \textendash{} The type of the dual mesh.
Defaults to the type of the provided mesh object.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} The dual mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_attribute:meshplus-edge-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_attribute::doc}}\index{edge\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_attribute:directional_clustering.mesh.MeshPlus.edge_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_attribute}}}{\emph{\DUrole{n}{edge}}, \emph{\DUrole{n}{name}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set an attribute of an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{edge} (\sphinxstyleemphasis{2\sphinxhyphen{}tuple of int}) \textendash{} The identifier of the edge as a pair of vertex identifiers.

\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute.

\item {} 
\sphinxstylestrong{value} (\sphinxstyleemphasis{obj, optional}) \textendash{} The value of the attribute.
Default is \sphinxcode{\sphinxupquote{None}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{object or None} \textendash{} The value of the attribute, or \sphinxcode{\sphinxupquote{None}} when the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the edge does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_attributes:meshplus-edge-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_attributes::doc}}\index{edge\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_attributes:directional_clustering.mesh.MeshPlus.edge_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_attributes}}}{\emph{\DUrole{n}{edge}}, \emph{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{values}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set multiple attributes of an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{edge} (\sphinxstyleemphasis{2\sphinxhyphen{}tuple of int}) \textendash{} The identifier of the edge.

\item {} 
\sphinxstylestrong{names} (\sphinxstyleemphasis{list, optional}) \textendash{} A list of attribute names.

\item {} 
\sphinxstylestrong{values} (\sphinxstyleemphasis{list, optional}) \textendash{} A list of attribute values.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict, list or None} \textendash{} If the parameter \sphinxcode{\sphinxupquote{names}} is empty,
a dictionary of all attribute name\sphinxhyphen{}value pairs of the edge.
If the parameter \sphinxcode{\sphinxupquote{names}} is not empty,
a list of the values corresponding to the provided names.
\sphinxcode{\sphinxupquote{None}} if the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the edge does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_coordinates}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_coordinates:meshplus-edge-coordinates}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_coordinates::doc}}\index{edge\_coordinates() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_coordinates()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_coordinates:directional_clustering.mesh.MeshPlus.edge_coordinates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_coordinates}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}, \emph{\DUrole{n}{axes}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xyz\textquotesingle{}}}}{}
Return the coordinates of the start and end point of an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The key of the start vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The key of the end vertex.

\item {} 
\sphinxstylestrong{axes} (\sphinxstyleemphasis{str (xyz)}) \textendash{} The axes along which the coordinates should be included.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{tuple} \textendash{} The coordinates of the start point and the coordinates of the end point.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_direction}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_direction:meshplus-edge-direction}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_direction::doc}}\index{edge\_direction() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_direction()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_direction:directional_clustering.mesh.MeshPlus.edge_direction}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_direction}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{}
Return the direction vector of an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The key of the start vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The key of the end vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The direction vector of the edge.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_faces}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_faces:meshplus-edge-faces}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_faces::doc}}\index{edge\_faces() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_faces()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_faces:directional_clustering.mesh.MeshPlus.edge_faces}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_faces}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{}
Find the two faces adjacent to an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the first vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the second vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{tuple} \textendash{} The identifiers of the adjacent faces.
If the edge is on the boundary, one of the identifiers is \sphinxcode{\sphinxupquote{None}}.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_length}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_length:meshplus-edge-length}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_length::doc}}\index{edge\_length() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_length()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_length:directional_clustering.mesh.MeshPlus.edge_length}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_length}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{}
Return the length of an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The key of the start vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The key of the end vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The length of the edge.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_loop}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_loop:meshplus-edge-loop}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_loop::doc}}\index{edge\_loop() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_loop()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_loop:directional_clustering.mesh.MeshPlus.edge_loop}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_loop}}}{\emph{\DUrole{n}{edge}}}{}
Find all edges on the same loop as a given edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{edge} (\sphinxstyleemphasis{tuple of int}) \textendash{} The identifier of the starting edge.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list of tuple of int} \textendash{} The edges on the same loop as the given edge.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_midpoint}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_midpoint:meshplus-edge-midpoint}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_midpoint::doc}}\index{edge\_midpoint() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_midpoint()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_midpoint:directional_clustering.mesh.MeshPlus.edge_midpoint}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_midpoint}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{}
Return the location of the midpoint of an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The key of the start vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The key of the end vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The XYZ coordinates of the midpoint.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_point}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_point:meshplus-edge-point}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_point::doc}}\index{edge\_point() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_point()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_point:directional_clustering.mesh.MeshPlus.edge_point}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_point}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}, \emph{\DUrole{n}{t}\DUrole{o}{=}\DUrole{default_value}{0.5}}}{}
Return the location of a point along an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The key of the start vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The key of the end vertex.

\item {} 
\sphinxstylestrong{t} (\sphinxstyleemphasis{float (0.5)}) \textendash{} The location of the point on the edge.
If the value of \sphinxcode{\sphinxupquote{t}} is outside the range \sphinxcode{\sphinxupquote{0\sphinxhyphen{}1}}, the point will
lie in the direction of the edge, but not on the edge vector.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The XYZ coordinates of the point.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_strip}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_strip:meshplus-edge-strip}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_strip::doc}}\index{edge\_strip() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_strip()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_strip:directional_clustering.mesh.MeshPlus.edge_strip}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_strip}}}{\emph{\DUrole{n}{edge}}}{}
Find all edges on the same strip as a given edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{edge} (\sphinxstyleemphasis{tuple of int}) \textendash{} The identifier of the starting edge.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list of tuple of int} \textendash{} The edges on the same strip as the given edge.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edge\_vector}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_vector:meshplus-edge-vector}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_vector::doc}}\index{edge\_vector() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edge\_vector()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edge_vector:directional_clustering.mesh.MeshPlus.edge_vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edge\_vector}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{}
Return the vector of an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The key of the start vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The key of the end vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The vector from u to v.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edges}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges:meshplus-edges}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges::doc}}\index{edges() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edges()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges:directional_clustering.mesh.MeshPlus.edges}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edges}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Iterate over the edges of the mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Return the edge data as well as the edge vertex keys.

\item[{Yields}] \leavevmode
\sphinxstyleemphasis{tuple} \textendash{} The next edge as a (u, v) tuple, if \sphinxcode{\sphinxupquote{data}} is false.
The next edge as a ((u, v), data) tuple, if \sphinxcode{\sphinxupquote{data}} is true.

\end{description}\end{quote}
\subsubsection*{Notes}

Mesh edges have no topological meaning. They are only used to store data.
Edges are not automatically created when vertices and faces are added to
the mesh. Instead, they are created when data is stored on them, or when
they are accessed using this method.

This method yields the directed edges of the mesh.
Unless edges were added explicitly using \sphinxcode{\sphinxupquote{add\_edge()}} the order of
edges is \sphinxstyleemphasis{as they come out}. However, as long as the toplogy remains
unchanged, the order is consistent.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.edges\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_attribute:meshplus-edges-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_attribute::doc}}\index{edges\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edges\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_attribute:directional_clustering.mesh.MeshPlus.edges_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edges\_attribute}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{keys}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set an attribute of multiple edges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute.

\item {} 
\sphinxstylestrong{value} (\sphinxstyleemphasis{obj, optional}) \textendash{} The value of the attribute.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{keys} (\sphinxstyleemphasis{list of edges, optional}) \textendash{} A list of edge identifiers.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list or None} \textendash{} A list containing the value per edge of the requested attribute,
or \sphinxcode{\sphinxupquote{None}} if the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If any of the edges does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edges\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_attributes:meshplus-edges-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_attributes::doc}}\index{edges\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edges\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_attributes:directional_clustering.mesh.MeshPlus.edges_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edges\_attributes}}}{\emph{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{values}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{keys}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set multiple attributes of multiple edges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{names} (\sphinxstyleemphasis{list of str, optional}) \textendash{} The names of the attribute.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{values} (\sphinxstyleemphasis{list of obj, optional}) \textendash{} The values of the attributes.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{keys} (\sphinxstyleemphasis{list of edges, optional}) \textendash{} A list of edge identifiers.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict, list or None} \textendash{} If the parameter \sphinxcode{\sphinxupquote{names}} is \sphinxcode{\sphinxupquote{None}},
a list containing per edge an attribute dict with all attributes (default + custom) of the edge.
If the parameter \sphinxcode{\sphinxupquote{names}} is \sphinxcode{\sphinxupquote{None}},
a list containing per edge a list of attribute values corresponding to the requested names.
\sphinxcode{\sphinxupquote{None}} if the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If any of the edges does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edges\_on\_boundaries}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_on_boundaries:meshplus-edges-on-boundaries}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_on_boundaries::doc}}\index{edges\_on\_boundaries() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edges\_on\_boundaries()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_on_boundaries:directional_clustering.mesh.MeshPlus.edges_on_boundaries}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edges\_on\_boundaries}}}{}{}
\end{fulllineitems}



\subparagraph{MeshPlus.edges\_on\_boundary}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_on_boundary:meshplus-edges-on-boundary}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_on_boundary::doc}}\index{edges\_on\_boundary() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edges\_on\_boundary()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_on_boundary:directional_clustering.mesh.MeshPlus.edges_on_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edges\_on\_boundary}}}{\emph{\DUrole{n}{oriented}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Find the edges on the boundary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{oriented} (\sphinxstyleemphasis{bool, optional}) \textendash{} If \sphinxcode{\sphinxupquote{False}} (default) the edges are aligned head\sphinxhyphen{}to\sphinxhyphen{}tail along the boundary.
If \sphinxcode{\sphinxupquote{True}} the edges have the same orientation as in the mesh.

\item[{Returns}] \leavevmode
\sphinxstylestrong{edges} (\sphinxstyleemphasis{list}) \textendash{} The boundary edges.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edges\_where}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_where:meshplus-edges-where}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_where::doc}}\index{edges\_where() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edges\_where()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_where:directional_clustering.mesh.MeshPlus.edges_where}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edges\_where}}}{\emph{\DUrole{n}{conditions}}, \emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Get edges for which a certain condition or set of conditions is true.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{conditions} (\sphinxstyleemphasis{dict}) \textendash{} A set of conditions in the form of key\sphinxhyphen{}value pairs.
The keys should be attribute names. The values can be attribute
values or ranges of attribute values in the form of min/max pairs.

\item {} 
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Yield the edges and their data attributes.
Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\item[{Yields}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{2\sphinxhyphen{}tuple} \textendash{} The next edge as a (u, v) tuple, if \sphinxcode{\sphinxupquote{data=False}}.

\item {} 
\sphinxstyleemphasis{3\sphinxhyphen{}tuple} \textendash{} The next edge as a (u, v, data) tuple, if \sphinxcode{\sphinxupquote{data=True}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.edges\_where\_predicate}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_where_predicate:meshplus-edges-where-predicate}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_where_predicate::doc}}\index{edges\_where\_predicate() (directional\_clustering.mesh.MeshPlus method)@\spxentry{edges\_where\_predicate()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.edges_where_predicate:directional_clustering.mesh.MeshPlus.edges_where_predicate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{edges\_where\_predicate}}}{\emph{\DUrole{n}{predicate}}, \emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Get edges for which a certain condition or set of conditions is true using a lambda function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{predicate} (\sphinxstyleemphasis{callable}) \textendash{} The condition you want to evaluate. The callable takes 3 parameters: \sphinxcode{\sphinxupquote{u}}, \sphinxcode{\sphinxupquote{v}}, \sphinxcode{\sphinxupquote{attr}} and should return \sphinxcode{\sphinxupquote{True}} or \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Yield the vertices and their data attributes.
Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\item[{Yields}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{2\sphinxhyphen{}tuple} \textendash{} The next edge as a (u, v) tuple, if \sphinxcode{\sphinxupquote{data=False}}.

\item {} 
\sphinxstyleemphasis{3\sphinxhyphen{}tuple} \textendash{} The next edge as a (u, v, data) tuple, if \sphinxcode{\sphinxupquote{data=True}}.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.euler}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.euler:meshplus-euler}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.euler::doc}}\index{euler() (directional\_clustering.mesh.MeshPlus method)@\spxentry{euler()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.euler:directional_clustering.mesh.MeshPlus.euler}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{euler}}}{}{}
Calculate the Euler characteristic.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The Euler characteristic.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_adjacency}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency:meshplus-face-adjacency}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency::doc}}\index{face\_adjacency() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_adjacency()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency:directional_clustering.mesh.MeshPlus.face_adjacency}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_adjacency}}}{}{}
Build a face adjacency dict.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{Mesh}) \textendash{} A mesh object.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} A dictionary mapping face identifiers (keys) to lists of neighboring faces.

\end{description}\end{quote}
\subsubsection*{Notes}

This algorithm is used primarily to unify the cycle directions of a given mesh.
Therefore, the premise is that the topological information of the mesh is corrupt
and cannot be used to construct the adjacency structure. The algorithm is thus
purely geometrical, but uses a spatial indexing tree to speed up the search.

\end{fulllineitems}



\subparagraph{MeshPlus.face\_adjacency\_halfedge}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency_halfedge:meshplus-face-adjacency-halfedge}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency_halfedge::doc}}\index{face\_adjacency\_halfedge() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_adjacency\_halfedge()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency_halfedge:directional_clustering.mesh.MeshPlus.face_adjacency_halfedge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_adjacency\_halfedge}}}{\emph{\DUrole{n}{f1}}, \emph{\DUrole{n}{f2}}}{}
Find one half\sphinxhyphen{}edge over which two faces are adjacent.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{f1} (\sphinxstyleemphasis{hashable}) \textendash{} The identifier of the first face.

\item {} 
\sphinxstylestrong{f2} (\sphinxstyleemphasis{hashable}) \textendash{} The identifier of the second face.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{tuple} \textendash{} The half\sphinxhyphen{}edge separating face 1 from face 2.

\item {} 
\sphinxstyleemphasis{None} \textendash{} If the faces are not adjacent.

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Notes}

For use in form\sphinxhyphen{}finding algorithms, that rely on form\sphinxhyphen{}force duality information,
further checks relating to the orientation of the corresponding are required.

\end{fulllineitems}



\subparagraph{MeshPlus.face\_adjacency\_vertices}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency_vertices:meshplus-face-adjacency-vertices}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency_vertices::doc}}\index{face\_adjacency\_vertices() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_adjacency\_vertices()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_adjacency_vertices:directional_clustering.mesh.MeshPlus.face_adjacency_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_adjacency\_vertices}}}{\emph{\DUrole{n}{f1}}, \emph{\DUrole{n}{f2}}}{}
Find all vertices over which two faces are adjacent.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{f1} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the first face.

\item {} 
\sphinxstylestrong{f2} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the second face.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{list} \textendash{} The vertices separating face 1 from face 2.

\item {} 
\sphinxstyleemphasis{None} \textendash{} If the faces are not adjacent.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_area}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_area:meshplus-face-area}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_area::doc}}\index{face\_area() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_area()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_area:directional_clustering.mesh.MeshPlus.face_area}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_area}}}{\emph{\DUrole{n}{fkey}}}{}
Compute the area of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The area of the face.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_aspect\_ratio}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_aspect_ratio:meshplus-face-aspect-ratio}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_aspect_ratio::doc}}\index{face\_aspect\_ratio() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_aspect\_ratio()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_aspect_ratio:directional_clustering.mesh.MeshPlus.face_aspect_ratio}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_aspect\_ratio}}}{\emph{\DUrole{n}{fkey}}}{}
Face aspect ratio as the ratio between the lengths of the maximum and minimum face edges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{Key}) \textendash{} The face key.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The aspect ratio.

\end{description}\end{quote}
\subsubsection*{References}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_attribute:meshplus-face-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_attribute::doc}}\index{face\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_attribute:directional_clustering.mesh.MeshPlus.face_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_attribute}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{name}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set an attribute of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The face identifier.

\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute.

\item {} 
\sphinxstylestrong{value} (\sphinxstyleemphasis{obj, optional}) \textendash{} The value of the attribute.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{object or None} \textendash{} The value of the attribute, or \sphinxcode{\sphinxupquote{None}} when the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the face does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_attributes:meshplus-face-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_attributes::doc}}\index{face\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_attributes:directional_clustering.mesh.MeshPlus.face_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_attributes}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{values}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set multiple attributes of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item {} 
\sphinxstylestrong{names} (\sphinxstyleemphasis{list, optional}) \textendash{} A list of attribute names.

\item {} 
\sphinxstylestrong{values} (\sphinxstyleemphasis{list, optional}) \textendash{} A list of attribute values.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict, list or None} \textendash{} If the parameter \sphinxcode{\sphinxupquote{names}} is empty,
a dictionary of all attribute name\sphinxhyphen{}value pairs of the face.
If the parameter \sphinxcode{\sphinxupquote{names}} is not empty,
a list of the values corresponding to the provided names.
\sphinxcode{\sphinxupquote{None}} if the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the face does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_center}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_center:meshplus-face-center}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_center::doc}}\index{face\_center() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_center()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_center:directional_clustering.mesh.MeshPlus.face_center}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_center}}}{\emph{\DUrole{n}{fkey}}}{}
Compute the location of the center of mass of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The coordinates of the center of mass.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_centroid}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_centroid:meshplus-face-centroid}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_centroid::doc}}\index{face\_centroid() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_centroid()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_centroid:directional_clustering.mesh.MeshPlus.face_centroid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_centroid}}}{\emph{\DUrole{n}{fkey}}}{}
Compute the location of the centroid of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The coordinates of the centroid.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_coordinates}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_coordinates:meshplus-face-coordinates}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_coordinates::doc}}\index{face\_coordinates() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_coordinates()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_coordinates:directional_clustering.mesh.MeshPlus.face_coordinates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_coordinates}}}{\emph{\DUrole{n}{fkey}}, \emph{\DUrole{n}{axes}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xyz\textquotesingle{}}}}{}
Compute the coordinates of the vertices of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item {} 
\sphinxstylestrong{axes} (\sphinxstyleemphasis{str, optional}) \textendash{} The axes along which to take the coordinates.
Should be a combination of \sphinxcode{\sphinxupquote{\textquotesingle{}x\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}y\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}z\textquotesingle{}}}.
Default is \sphinxcode{\sphinxupquote{\textquotesingle{}xyz\textquotesingle{}}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list of list} \textendash{} The coordinates of the vertices of the face.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_corners}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_corners:meshplus-face-corners}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_corners::doc}}\index{face\_corners() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_corners()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_corners:directional_clustering.mesh.MeshPlus.face_corners}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_corners}}}{\emph{\DUrole{n}{fkey}}}{}
Return triplets of face vertices forming the corners of the face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} Identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The corners of the face in the form of a list of vertex triplets.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_curvature}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_curvature:meshplus-face-curvature}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_curvature::doc}}\index{face\_curvature() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_curvature()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_curvature:directional_clustering.mesh.MeshPlus.face_curvature}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_curvature}}}{\emph{\DUrole{n}{fkey}}}{}
Dimensionless face curvature as the maximum face vertex deviation from
the best\sphinxhyphen{}fit plane of the face vertices divided by the average lengths of
the face vertices to the face centroid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{Key}) \textendash{} The face key.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The dimensionless curvature.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_degree}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_degree:meshplus-face-degree}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_degree::doc}}\index{face\_degree() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_degree()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_degree:directional_clustering.mesh.MeshPlus.face_degree}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_degree}}}{\emph{\DUrole{n}{fkey}}}{}
Count the neighbors of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} Identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The count.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_flatness}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_flatness:meshplus-face-flatness}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_flatness::doc}}\index{face\_flatness() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_flatness()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_flatness:directional_clustering.mesh.MeshPlus.face_flatness}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_flatness}}}{\emph{\DUrole{n}{fkey}}, \emph{\DUrole{n}{maxdev}\DUrole{o}{=}\DUrole{default_value}{0.02}}}{}
Compute the flatness of the mesh face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item {} 
\sphinxstylestrong{maxdev} (\sphinxstyleemphasis{float, optional}) \textendash{} A maximum value for the allowed deviation from flatness.
Default is \sphinxcode{\sphinxupquote{0.02}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The flatness.

\end{description}\end{quote}
\subsubsection*{Notes}

Flatness is computed as the ratio of the distance between the diagonals
of the face to the average edge length. A practical limit on this value
realted to manufacturing is 0.02 (2\%).

\begin{sphinxadmonition}{warning}{Warning:}
This method only makes sense for quadrilateral faces.
\end{sphinxadmonition}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_halfedges}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_halfedges:meshplus-face-halfedges}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_halfedges::doc}}\index{face\_halfedges() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_halfedges()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_halfedges:directional_clustering.mesh.MeshPlus.face_halfedges}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_halfedges}}}{\emph{\DUrole{n}{fkey}}}{}
The halfedges of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} Identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The halfedges of a face.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_max\_degree}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_max_degree:meshplus-face-max-degree}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_max_degree::doc}}\index{face\_max\_degree() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_max\_degree()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_max_degree:directional_clustering.mesh.MeshPlus.face_max_degree}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_max\_degree}}}{}{}
Compute the maximum degree of all faces.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The highest degree.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_min\_degree}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_min_degree:meshplus-face-min-degree}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_min_degree::doc}}\index{face\_min\_degree() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_min\_degree()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_min_degree:directional_clustering.mesh.MeshPlus.face_min_degree}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_min\_degree}}}{}{}
Compute the minimum degree of all faces.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The lowest degree.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_neighborhood}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_neighborhood:meshplus-face-neighborhood}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_neighborhood::doc}}\index{face\_neighborhood() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_neighborhood()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_neighborhood:directional_clustering.mesh.MeshPlus.face_neighborhood}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_neighborhood}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{ring}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Return the faces in the neighborhood of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item {} 
\sphinxstylestrong{ring} (\sphinxstyleemphasis{int, optional}) \textendash{} The size of the neighborhood.
Default is \sphinxcode{\sphinxupquote{1}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} A list of face identifiers.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_neighbors}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_neighbors:meshplus-face-neighbors}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_neighbors::doc}}\index{face\_neighbors() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_neighbors()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_neighbors:directional_clustering.mesh.MeshPlus.face_neighbors}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_neighbors}}}{\emph{\DUrole{n}{fkey}}}{}
Return the neighbors of a face across its edges.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} Identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The identifiers of the neighboring faces.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_normal}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_normal:meshplus-face-normal}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_normal::doc}}\index{face\_normal() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_normal()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_normal:directional_clustering.mesh.MeshPlus.face_normal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_normal}}}{\emph{\DUrole{n}{fkey}}, \emph{\DUrole{n}{unitized}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Compute the normal of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item {} 
\sphinxstylestrong{unitized} (\sphinxstyleemphasis{bool, optional}) \textendash{} Unitize the normal vector.
Default is \sphinxcode{\sphinxupquote{True}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The components of the normal vector.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_plane}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_plane:meshplus-face-plane}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_plane::doc}}\index{face\_plane() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_plane()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_plane:directional_clustering.mesh.MeshPlus.face_plane}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_plane}}}{\emph{\DUrole{n}{face}}}{}
A plane defined by the centroid and the normal of the face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{face} (\sphinxstyleemphasis{int}) \textendash{} The face identifier.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{tuple} \textendash{} point, vector

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_skewness}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_skewness:meshplus-face-skewness}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_skewness::doc}}\index{face\_skewness() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_skewness()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_skewness:directional_clustering.mesh.MeshPlus.face_skewness}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_skewness}}}{\emph{\DUrole{n}{fkey}}}{}
Face skewness as the maximum absolute angular deviation from the ideal polygon angle.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{Key}) \textendash{} The face key.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The skewness.

\end{description}\end{quote}
\subsubsection*{References}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_vertex\_ancestor}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertex_ancestor:meshplus-face-vertex-ancestor}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertex_ancestor::doc}}\index{face\_vertex\_ancestor() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_vertex\_ancestor()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertex_ancestor:directional_clustering.mesh.MeshPlus.face_vertex_ancestor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_vertex\_ancestor}}}{\emph{\DUrole{n}{fkey}}, \emph{\DUrole{n}{key}}, \emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Return the n\sphinxhyphen{}th vertex before the specified vertex in a specific face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} Identifier of the face.

\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item {} 
\sphinxstylestrong{n} (\sphinxstyleemphasis{int, optional}) \textendash{} The index of the vertex ancestor. Default is 1, meaning the previous vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The identifier of the vertex before the given vertex in the face cycle.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If the vertex is not part of the face.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_vertex\_descendant}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertex_descendant:meshplus-face-vertex-descendant}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertex_descendant::doc}}\index{face\_vertex\_descendant() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_vertex\_descendant()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertex_descendant:directional_clustering.mesh.MeshPlus.face_vertex_descendant}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_vertex\_descendant}}}{\emph{\DUrole{n}{fkey}}, \emph{\DUrole{n}{key}}, \emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Return the n\sphinxhyphen{}th vertex after the specified vertex in a specific face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} Identifier of the face.

\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item {} 
\sphinxstylestrong{n} (\sphinxstyleemphasis{int, optional}) \textendash{} The index of the vertex descendant. Default is 1, meaning the next vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The identifier of the vertex after the given vertex in the face cycle.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If the vertex is not part of the face.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.face\_vertices}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertices:meshplus-face-vertices}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertices::doc}}\index{face\_vertices() (directional\_clustering.mesh.MeshPlus method)@\spxentry{face\_vertices()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.face_vertices:directional_clustering.mesh.MeshPlus.face_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{face\_vertices}}}{\emph{\DUrole{n}{fkey}}}{}
The vertices of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} Identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} Ordered vertex identifiers.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.faces}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces:meshplus-faces}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces::doc}}\index{faces() (directional\_clustering.mesh.MeshPlus method)@\spxentry{faces()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces:directional_clustering.mesh.MeshPlus.faces}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{faces}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Iterate over the faces of the mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Return the face data as well as the face keys.

\item[{Yields}] \leavevmode
\sphinxstyleemphasis{int or tuple} \textendash{} The next face identifier, if \sphinxcode{\sphinxupquote{data}} is \sphinxcode{\sphinxupquote{False}}.
The next face as a (fkey, attr) tuple, if \sphinxcode{\sphinxupquote{data}} is \sphinxcode{\sphinxupquote{True}}.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.faces\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_attribute:meshplus-faces-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_attribute::doc}}\index{faces\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{faces\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_attribute:directional_clustering.mesh.MeshPlus.faces_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{faces\_attribute}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{keys}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set an attribute of multiple faces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute.

\item {} 
\sphinxstylestrong{value} (\sphinxstyleemphasis{obj, optional}) \textendash{} The value of the attribute.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{keys} (\sphinxstyleemphasis{list of int, optional}) \textendash{} A list of face identifiers.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list or None} \textendash{} A list containing the value per face of the requested attribute,
or \sphinxcode{\sphinxupquote{None}} if the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If any of the faces does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.faces\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_attributes:meshplus-faces-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_attributes::doc}}\index{faces\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{faces\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_attributes:directional_clustering.mesh.MeshPlus.faces_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{faces\_attributes}}}{\emph{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{values}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{keys}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set multiple attributes of multiple faces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{names} (\sphinxstyleemphasis{list of str, optional}) \textendash{} The names of the attribute.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{values} (\sphinxstyleemphasis{list of obj, optional}) \textendash{} The values of the attributes.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{keys} (\sphinxstyleemphasis{list of int, optional}) \textendash{} A list of face identifiers.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict, list or None} \textendash{} If the parameter \sphinxcode{\sphinxupquote{names}} is \sphinxcode{\sphinxupquote{None}},
a list containing per face an attribute dict with all attributes (default + custom) of the face.
If the parameter \sphinxcode{\sphinxupquote{names}} is \sphinxcode{\sphinxupquote{None}},
a list containing per face a list of attribute values corresponding to the requested names.
\sphinxcode{\sphinxupquote{None}} if the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If any of the faces does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.faces\_on\_boundary}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_on_boundary:meshplus-faces-on-boundary}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_on_boundary::doc}}\index{faces\_on\_boundary() (directional\_clustering.mesh.MeshPlus method)@\spxentry{faces\_on\_boundary()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_on_boundary:directional_clustering.mesh.MeshPlus.faces_on_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{faces\_on\_boundary}}}{}{}
Find the faces on the boundary.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The faces on the boundary.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.faces\_where}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_where:meshplus-faces-where}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_where::doc}}\index{faces\_where() (directional\_clustering.mesh.MeshPlus method)@\spxentry{faces\_where()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_where:directional_clustering.mesh.MeshPlus.faces_where}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{faces\_where}}}{\emph{\DUrole{n}{conditions}}, \emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Get faces for which a certain condition or set of conditions is true.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{conditions} (\sphinxstyleemphasis{dict}) \textendash{} A set of conditions in the form of key\sphinxhyphen{}value pairs.
The keys should be attribute names. The values can be attribute
values or ranges of attribute values in the form of min/max pairs.

\item {} 
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Yield the faces and their data attributes.
Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\item[{Yields}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{hashable}) \textendash{} The next face that matches the condition.

\item {} 
\sphinxstyleemphasis{2\sphinxhyphen{}tuple} \textendash{} The next face and its attributes, if \sphinxcode{\sphinxupquote{data=True}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.faces\_where\_predicate}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_where_predicate:meshplus-faces-where-predicate}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_where_predicate::doc}}\index{faces\_where\_predicate() (directional\_clustering.mesh.MeshPlus method)@\spxentry{faces\_where\_predicate()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.faces_where_predicate:directional_clustering.mesh.MeshPlus.faces_where_predicate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{faces\_where\_predicate}}}{\emph{\DUrole{n}{predicate}}, \emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Get faces for which a certain condition or set of conditions is true using a lambda function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{predicate} (\sphinxstyleemphasis{callable}) \textendash{} The condition you want to evaluate. The callable takes 2 parameters: \sphinxcode{\sphinxupquote{key}}, \sphinxcode{\sphinxupquote{attr}} and should return \sphinxcode{\sphinxupquote{True}} or \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Yield the faces and their data attributes.
Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\item[{Yields}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{hashable}) \textendash{} The next face that matches the condition.

\item {} 
\sphinxstyleemphasis{2\sphinxhyphen{}tuple} \textendash{} The next face and its attributes, if \sphinxcode{\sphinxupquote{data=True}}.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.flip\_cycles}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.flip_cycles:meshplus-flip-cycles}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.flip_cycles::doc}}\index{flip\_cycles() (directional\_clustering.mesh.MeshPlus method)@\spxentry{flip\_cycles()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.flip_cycles:directional_clustering.mesh.MeshPlus.flip_cycles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{flip\_cycles}}}{}{}
Flip the cycle directions of all faces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{Mesh}) \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Notes}

This function does not care about the directions being unified or not. It
just reverses whatever direction it finds.

\end{fulllineitems}



\subparagraph{MeshPlus.from\_data}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_data:meshplus-from-data}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_data::doc}}\index{from\_data() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_data()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_data:directional_clustering.mesh.MeshPlus.from_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_data}}}{\emph{\DUrole{n}{data}}}{}
Construct a datastructure from structured data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{data} (\sphinxstyleemphasis{dict}) \textendash{} The data dictionary.

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{compas.datastructures.Datastructure}} \textendash{} An object of the type of \sphinxcode{\sphinxupquote{cls}}.

\end{description}\end{quote}
\subsubsection*{Notes}

This constructor method is meant to be used in conjunction with the
corresponding \sphinxstyleemphasis{to\_data} method.

\end{fulllineitems}



\subparagraph{MeshPlus.from\_json}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_json:meshplus-from-json}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_json::doc}}\index{from\_json() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_json()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_json:directional_clustering.mesh.MeshPlus.from_json}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_json}}}{\emph{\DUrole{n}{filepath}}}{}
Construct a datastructure from structured data contained in a json file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the json file.

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{compas.datastructures.Datastructure}} \textendash{} An object of the type of \sphinxcode{\sphinxupquote{cls}}.

\end{description}\end{quote}
\subsubsection*{Notes}

This constructor method is meant to be used in conjunction with the
corresponding \sphinxstyleemphasis{to\_json} method.

\end{fulllineitems}



\subparagraph{MeshPlus.from\_lines}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_lines:meshplus-from-lines}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_lines::doc}}\index{from\_lines() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_lines()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_lines:directional_clustering.mesh.MeshPlus.from_lines}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_lines}}}{\emph{\DUrole{n}{lines}}, \emph{\DUrole{n}{delete\_boundary\_face}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Construct a mesh object from a list of lines described by start and end point coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{lines} (\sphinxstyleemphasis{list}) \textendash{} A list of pairs of point coordinates.

\item {} 
\sphinxstylestrong{delete\_boundary\_face} (\sphinxstyleemphasis{bool, optional}) \textendash{} The algorithm that finds the faces formed by the connected lines
first finds the face \sphinxstyleemphasis{on the outside}. In most cases this face is not expected
to be there. Therefore, there is the option to have it automatically deleted.

\item {} 
\sphinxstylestrong{precision} (\sphinxstyleemphasis{str, optional}) \textendash{} The precision of the geometric map that is used to connect the lines.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_obj}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_obj:meshplus-from-obj}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_obj::doc}}\index{from\_obj() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_obj()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_obj:directional_clustering.mesh.MeshPlus.from_obj}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_obj}}}{\emph{\DUrole{n}{filepath}}, \emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Construct a mesh object from the data described in an OBJ file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the file.

\item {} 
\sphinxstylestrong{precision} (\sphinxstyleemphasis{str, optional}) \textendash{} The precision of the geometric map that is used to connect the lines.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Notes}

There are a few sample files available for testing and debugging:
\begin{itemize}
\item {} 
faces.obj

\item {} 
faces\_big.obj

\item {} 
faces\_reversed.obj

\item {} 
hypar.obj

\item {} 
mesh.obj

\item {} 
quadmesh.obj

\end{itemize}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_off}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_off:meshplus-from-off}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_off::doc}}\index{from\_off() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_off()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_off:directional_clustering.mesh.MeshPlus.from_off}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_off}}}{\emph{\DUrole{n}{filepath}}}{}
Construct a mesh object from the data described in a OFF file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the file.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_ply}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_ply:meshplus-from-ply}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_ply::doc}}\index{from\_ply() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_ply()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_ply:directional_clustering.mesh.MeshPlus.from_ply}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_ply}}}{\emph{\DUrole{n}{filepath}}, \emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Construct a mesh object from the data described in a PLY file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the file.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_points}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_points:meshplus-from-points}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_points::doc}}\index{from\_points() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_points()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_points:directional_clustering.mesh.MeshPlus.from_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_points}}}{\emph{\DUrole{n}{points}}, \emph{\DUrole{n}{boundary}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{holes}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Construct a mesh from a delaunay triangulation of a set of points.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{points} (\sphinxstyleemphasis{list}) \textendash{} XYZ coordinates of the points.
Z coordinates should be zero.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_polygons}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polygons:meshplus-from-polygons}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polygons::doc}}\index{from\_polygons() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_polygons()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polygons:directional_clustering.mesh.MeshPlus.from_polygons}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_polygons}}}{\emph{\DUrole{n}{polygons}}, \emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Construct a mesh from a series of polygons.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{polygons} (\sphinxstyleemphasis{list}) \textendash{} A list of polygons, with each polygon defined as an ordered list of
XYZ coordinates of its corners.

\item {} 
\sphinxstylestrong{precision} (\sphinxstyleemphasis{str, optional}) \textendash{} The precision of the geometric map that is used to connect the lines.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_polyhedron}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polyhedron:meshplus-from-polyhedron}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polyhedron::doc}}\index{from\_polyhedron() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_polyhedron()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polyhedron:directional_clustering.mesh.MeshPlus.from_polyhedron}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_polyhedron}}}{\emph{\DUrole{n}{f}}}{}
Construct a mesh from a platonic solid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{f} (\sphinxstyleemphasis{int}) \textendash{} The number of faces.
Should be one of \sphinxcode{\sphinxupquote{4, 6, 8, 12, 20}}.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_polylines}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polylines:meshplus-from-polylines}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polylines::doc}}\index{from\_polylines() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_polylines()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_polylines:directional_clustering.mesh.MeshPlus.from_polylines}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_polylines}}}{\emph{\DUrole{n}{boundary\_polylines}}, \emph{\DUrole{n}{other\_polylines}}}{}
Construct mesh from polylines.

Based on construction from\_lines,
with removal of vertices that are not polyline extremities
and of faces that represent boundaries.

This specific method is useful to get the mesh connectivity from a set of (discretised) curves,
that could overlap and yield a wrong connectivity if using from\_lines based on the polyline extremities only.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{boundary\_polylines} (\sphinxstyleemphasis{list}) \textendash{} List of polylines representing boundaries as lists of vertex coordinates.

\item {} 
\sphinxstylestrong{other\_polylines} (\sphinxstyleemphasis{list}) \textendash{} List of the other polylines as lists of vertex coordinates.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_shape}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_shape:meshplus-from-shape}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_shape::doc}}\index{from\_shape() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_shape()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_shape:directional_clustering.mesh.MeshPlus.from_shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_shape}}}{\emph{\DUrole{n}{shape}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Construct a mesh from a primitive shape.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{shape} (:class: \sphinxtitleref{compas.geometry.shape}) \textendash{} The input shape to generate a mesh from.

\item {} 
\sphinxstylestrong{kwargs} \textendash{} Optional keyword arguments \sphinxcode{\sphinxupquote{u}} and \sphinxcode{\sphinxupquote{v}} for the resolution in u (Torus, Sphere, Cylinder, Cone) and v direction (Torus and Sphere).

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_stl}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_stl:meshplus-from-stl}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_stl::doc}}\index{from\_stl() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_stl()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_stl:directional_clustering.mesh.MeshPlus.from_stl}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_stl}}}{\emph{\DUrole{n}{filepath}}, \emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Construct a mesh object from the data described in a STL file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the file.

\item {} 
\sphinxstylestrong{precision} (\sphinxstyleemphasis{str, optional}) \textendash{} The precision of the geometric map that is used to connect the lines.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.from\_vertices\_and\_faces}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_vertices_and_faces:meshplus-from-vertices-and-faces}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_vertices_and_faces::doc}}\index{from\_vertices\_and\_faces() (directional\_clustering.mesh.MeshPlus class method)@\spxentry{from\_vertices\_and\_faces()}\spxextra{directional\_clustering.mesh.MeshPlus class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.from_vertices_and_faces:directional_clustering.mesh.MeshPlus.from_vertices_and_faces}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{from\_vertices\_and\_faces}}}{\emph{\DUrole{n}{vertices}}, \emph{\DUrole{n}{faces}}}{}
Construct a mesh object from a list of vertices and faces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{vertices} (\sphinxstyleemphasis{list, dict}) \textendash{} A list of vertices, represented by their XYZ coordinates,
or a dictionary of vertex keys pointing to their XYZ coordinates.

\item {} 
\sphinxstylestrong{faces} (\sphinxstyleemphasis{list, dict}) \textendash{} A list of faces, represented by a list of indices referencing the list of vertex coordinates,
or a dictionary of face keys pointing to a list of indices referencing the list of vertex coordinates.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A mesh object.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.genus}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.genus:meshplus-genus}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.genus::doc}}\index{genus() (directional\_clustering.mesh.MeshPlus method)@\spxentry{genus()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.genus:directional_clustering.mesh.MeshPlus.genus}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{genus}}}{}{}
Calculate the genus.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The genus.

\end{description}\end{quote}
\subsubsection*{References}

\end{fulllineitems}



\subparagraph{MeshPlus.get\_any\_face}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_face:meshplus-get-any-face}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_face::doc}}\index{get\_any\_face() (directional\_clustering.mesh.MeshPlus method)@\spxentry{get\_any\_face()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_face:directional_clustering.mesh.MeshPlus.get_any_face}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{get\_any\_face}}}{}{}
Get the identifier of a random face.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{hashable} \textendash{} The identifier of the face.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.get\_any\_face\_vertex}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_face_vertex:meshplus-get-any-face-vertex}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_face_vertex::doc}}\index{get\_any\_face\_vertex() (directional\_clustering.mesh.MeshPlus method)@\spxentry{get\_any\_face\_vertex()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_face_vertex:directional_clustering.mesh.MeshPlus.get_any_face_vertex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{get\_any\_face\_vertex}}}{\emph{\DUrole{n}{fkey}}}{}
Get the identifier of a random vertex of a specific face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{hashable}) \textendash{} The identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{hashable} \textendash{} The identifier of the vertex.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.get\_any\_vertex}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_vertex:meshplus-get-any-vertex}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_vertex::doc}}\index{get\_any\_vertex() (directional\_clustering.mesh.MeshPlus method)@\spxentry{get\_any\_vertex()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_vertex:directional_clustering.mesh.MeshPlus.get_any_vertex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{get\_any\_vertex}}}{}{}
Get the identifier of a random vertex.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{hashable} \textendash{} The identifier of the vertex.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.get\_any\_vertices}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_vertices:meshplus-get-any-vertices}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_vertices::doc}}\index{get\_any\_vertices() (directional\_clustering.mesh.MeshPlus method)@\spxentry{get\_any\_vertices()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.get_any_vertices:directional_clustering.mesh.MeshPlus.get_any_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{get\_any\_vertices}}}{\emph{\DUrole{n}{n}}, \emph{\DUrole{n}{exclude\_leaves}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Get a list of identifiers of a random set of n vertices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{n} (\sphinxstyleemphasis{int}) \textendash{} The number of random vertices.

\item {} 
\sphinxstylestrong{exclude\_leaves} (\sphinxstyleemphasis{bool (False)}) \textendash{} Exclude the leaves (vertices with only one connected edge) from the set.
Default is to include the leaves.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The identifiers of the vertices.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.gkey\_key}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.gkey_key:meshplus-gkey-key}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.gkey_key::doc}}\index{gkey\_key() (directional\_clustering.mesh.MeshPlus method)@\spxentry{gkey\_key()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.gkey_key:directional_clustering.mesh.MeshPlus.gkey_key}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{gkey\_key}}}{\emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns a dictionary that maps \sphinxstyleemphasis{geometric keys} of a certain precision
to the keys of the corresponding vertices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{precision} (\sphinxstyleemphasis{str (3f)}) \textendash{} The float precision specifier used in string formatting.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} A dictionary of geometric key\sphinxhyphen{}key pairs.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.halfedge\_face}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.halfedge_face:meshplus-halfedge-face}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.halfedge_face::doc}}\index{halfedge\_face() (directional\_clustering.mesh.MeshPlus method)@\spxentry{halfedge\_face()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.halfedge_face:directional_clustering.mesh.MeshPlus.halfedge_face}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{halfedge\_face}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{}
Find the face corresponding to a halfedge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the first vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the second vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int or None} \textendash{} The identifier of the face corresponding to the halfedge.
None, if the halfedge is on the outside of a boundary.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the halfedge does not exist.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.has\_edge}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_edge:meshplus-has-edge}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_edge::doc}}\index{has\_edge() (directional\_clustering.mesh.MeshPlus method)@\spxentry{has\_edge()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_edge:directional_clustering.mesh.MeshPlus.has_edge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{has\_edge}}}{\emph{\DUrole{n}{key}}}{}
Verify that the mesh contains a specific edge.

\begin{sphinxadmonition}{warning}{Warning:}
This method may produce unexpected results.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{tuple of int}) \textendash{} The identifier of the edge.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if the edge exists.
False otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.has\_face}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_face:meshplus-has-face}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_face::doc}}\index{has\_face() (directional\_clustering.mesh.MeshPlus method)@\spxentry{has\_face()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_face:directional_clustering.mesh.MeshPlus.has_face}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{has\_face}}}{\emph{\DUrole{n}{fkey}}}{}
Verify that a face is part of the mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if the face exists.
False otherwise.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.has\_halfedge}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_halfedge:meshplus-has-halfedge}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_halfedge::doc}}\index{has\_halfedge() (directional\_clustering.mesh.MeshPlus method)@\spxentry{has\_halfedge()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_halfedge:directional_clustering.mesh.MeshPlus.has_halfedge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{has\_halfedge}}}{\emph{\DUrole{n}{key}}}{}
Verify that a halfedge is part of the mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{tuple of int}) \textendash{} The identifier of the halfedge.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if the halfedge is part of the mesh.
False otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.has\_vertex}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_vertex:meshplus-has-vertex}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_vertex::doc}}\index{has\_vertex() (directional\_clustering.mesh.MeshPlus method)@\spxentry{has\_vertex()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.has_vertex:directional_clustering.mesh.MeshPlus.has_vertex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{has\_vertex}}}{\emph{\DUrole{n}{key}}}{}
Verify that a vertex is in the mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if the vertex is in the mesh.
False otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.index\_key}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.index_key:meshplus-index-key}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.index_key::doc}}\index{index\_key() (directional\_clustering.mesh.MeshPlus method)@\spxentry{index\_key()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.index_key:directional_clustering.mesh.MeshPlus.index_key}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{index\_key}}}{}{}
Returns a dictionary that maps the indices of a vertex list to
keys in a vertex dictionary.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} A dictionary of index\sphinxhyphen{}key pairs.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.index\_vertex}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.index_vertex:meshplus-index-vertex}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.index_vertex::doc}}\index{index\_vertex() (directional\_clustering.mesh.MeshPlus method)@\spxentry{index\_vertex()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.index_vertex:directional_clustering.mesh.MeshPlus.index_vertex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{index\_vertex}}}{}{}
Returns a dictionary that maps the indices of a vertex list to
keys in a vertex dictionary.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} A dictionary of index\sphinxhyphen{}key pairs.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.insert\_vertex}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.insert_vertex:meshplus-insert-vertex}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.insert_vertex::doc}}\index{insert\_vertex() (directional\_clustering.mesh.MeshPlus method)@\spxentry{insert\_vertex()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.insert_vertex:directional_clustering.mesh.MeshPlus.insert_vertex}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{insert\_vertex}}}{\emph{\DUrole{n}{fkey}}, \emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{xyz}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{return\_fkeys}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Insert a vertex in the specified face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The key of the face in which the vertex should be inserted.

\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int, optional}) \textendash{} The key to be used to identify the inserted vertex.

\item {} 
\sphinxstylestrong{xyz} (\sphinxstyleemphasis{list, optional}) \textendash{} Specific XYZ coordinates for the inserted vertex.

\item {} 
\sphinxstylestrong{return\_fkeys} (\sphinxstyleemphasis{bool, optional}) \textendash{} By default, this method returns only the key of the inserted vertex.
This flag can be used to indicate that the keys of the newly created
faces should be returned as well.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{int} \textendash{} The key of the inserted vertex, if \sphinxcode{\sphinxupquote{return\_fkeys}} is false.

\item {} 
\sphinxstyleemphasis{tuple} \textendash{} The key of the newly created vertex
and a list with the newly created faces, if \sphinxcode{\sphinxupquote{return\_fkeys}} is true.

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_connected}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_connected:meshplus-is-connected}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_connected::doc}}\index{is\_connected() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_connected()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_connected:directional_clustering.mesh.MeshPlus.is_connected}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_connected}}}{}{}
Verify that the mesh is connected.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} A mesh data structure.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True, if the mesh is connected.
False, otherwise.

\end{description}\end{quote}
\subsubsection*{Notes}

A mesh is connected if for every two vertices a path exists connecting them.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh\PYGZus{}is\PYGZus{}connected}\PYG{p}{(}\PYG{n}{m1}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh\PYGZus{}is\PYGZus{}connected}\PYG{p}{(}\PYG{n}{m2}\PYG{p}{)}
\PYG{g+go}{True}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh\PYGZus{}is\PYGZus{}connected}\PYG{p}{(}\PYG{n}{m3}\PYG{p}{)}
\PYG{g+go}{False}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_edge\_on\_boundary}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_edge_on_boundary:meshplus-is-edge-on-boundary}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_edge_on_boundary::doc}}\index{is\_edge\_on\_boundary() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_edge\_on\_boundary()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_edge_on_boundary:directional_clustering.mesh.MeshPlus.is_edge_on_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_edge\_on\_boundary}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{}
Verify that an edge is on the boundary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the first vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the second vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if the edge is on the boundary.
False otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_empty}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_empty:meshplus-is-empty}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_empty::doc}}\index{is\_empty() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_empty()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_empty:directional_clustering.mesh.MeshPlus.is_empty}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_empty}}}{}{}
Boolean whether the mesh is empty.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if no vertices. False otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_face\_on\_boundary}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_face_on_boundary:meshplus-is-face-on-boundary}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_face_on_boundary::doc}}\index{is\_face\_on\_boundary() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_face\_on\_boundary()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_face_on_boundary:directional_clustering.mesh.MeshPlus.is_face_on_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_face\_on\_boundary}}}{\emph{\DUrole{n}{key}}}{}
Verify that a face is on a boundary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the face.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if the face is on the boundary.
False otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_manifold}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_manifold:meshplus-is-manifold}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_manifold::doc}}\index{is\_manifold() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_manifold()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_manifold:directional_clustering.mesh.MeshPlus.is_manifold}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_manifold}}}{}{}
Verify that the mesh is manifold.

A mesh is manifold if the following conditions are fulfilled:
\begin{itemize}
\item {} 
Each edge is incident to only one or two faces.

\item {} 
The faces incident to a vertex form a closed or an open fan.

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True, if the mesh is manifold.
False, otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_orientable}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_orientable:meshplus-is-orientable}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_orientable::doc}}\index{is\_orientable() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_orientable()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_orientable:directional_clustering.mesh.MeshPlus.is_orientable}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_orientable}}}{}{}
Verify that the mesh is orientable.

A manifold mesh is orientable if the following conditions are fulfilled:
\begin{itemize}
\item {} 
Any two adjacent faces have compatible orientation, i.e. the faces have a unified cycle direction.

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True, if the mesh is orientable.
False, otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_quadmesh}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_quadmesh:meshplus-is-quadmesh}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_quadmesh::doc}}\index{is\_quadmesh() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_quadmesh()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_quadmesh:directional_clustering.mesh.MeshPlus.is_quadmesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_quadmesh}}}{}{}
Verify that the mesh consists of only quads.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True, if the mesh is a quad mesh.
False, otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_regular}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_regular:meshplus-is-regular}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_regular::doc}}\index{is\_regular() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_regular()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_regular:directional_clustering.mesh.MeshPlus.is_regular}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_regular}}}{}{}
Verify that the mesh is regular.

A mesh is regular if the following conditions are fulfilled:
\begin{itemize}
\item {} 
All faces have the same number of edges.

\item {} 
All vertices have the same degree, i.e. they are incident to the same number of edges.

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True, if the mesh is regular.
False, otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_trimesh}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_trimesh:meshplus-is-trimesh}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_trimesh::doc}}\index{is\_trimesh() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_trimesh()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_trimesh:directional_clustering.mesh.MeshPlus.is_trimesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_trimesh}}}{}{}
Verify that the mesh consists of only triangles.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True, if the mesh is a triangle mesh.
False, otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_valid}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_valid:meshplus-is-valid}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_valid::doc}}\index{is\_valid() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_valid()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_valid:directional_clustering.mesh.MeshPlus.is_valid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_valid}}}{}{}
Verify that the mesh is valid.

A mesh is valid if the following conditions are fulfilled:
\begin{itemize}
\item {} 
halfedges don’t point at non\sphinxhyphen{}existing faces

\item {} 
all vertices are in the halfedge dict

\item {} 
there are no None\sphinxhyphen{}None halfedges

\item {} 
all faces have corresponding halfedge entries

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True, if the mesh is valid.
False, otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_vertex\_connected}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_vertex_connected:meshplus-is-vertex-connected}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_vertex_connected::doc}}\index{is\_vertex\_connected() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_vertex\_connected()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_vertex_connected:directional_clustering.mesh.MeshPlus.is_vertex_connected}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_vertex\_connected}}}{\emph{\DUrole{n}{key}}}{}
Verify that a vertex is connected.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if the vertex is connected to at least one other vertex.
False otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.is\_vertex\_on\_boundary}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_vertex_on_boundary:meshplus-is-vertex-on-boundary}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_vertex_on_boundary::doc}}\index{is\_vertex\_on\_boundary() (directional\_clustering.mesh.MeshPlus method)@\spxentry{is\_vertex\_on\_boundary()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.is_vertex_on_boundary:directional_clustering.mesh.MeshPlus.is_vertex_on_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{is\_vertex\_on\_boundary}}}{\emph{\DUrole{n}{key}}}{}
Verify that a vertex is on a boundary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{bool} \textendash{} True if the vertex is on the boundary.
False otherwise.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.join}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.join:meshplus-join}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.join::doc}}\index{join() (directional\_clustering.mesh.MeshPlus method)@\spxentry{join()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.join:directional_clustering.mesh.MeshPlus.join}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{join}}}{\emph{\DUrole{n}{other}}}{}
Add the vertices and faces of another mesh to the current mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{other} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} The other mesh.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None} \textendash{} The mesh is modified in place.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{compas}\PYG{n+nn}{.}\PYG{n+nn}{geometry} \PYG{k+kn}{import} \PYG{n}{Box}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{compas}\PYG{n+nn}{.}\PYG{n+nn}{geometry} \PYG{k+kn}{import} \PYG{n}{Translation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{compas}\PYG{n+nn}{.}\PYG{n+nn}{datastructures} \PYG{k+kn}{import} \PYG{n}{Mesh}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Box}\PYG{o}{.}\PYG{n}{from\PYGZus{}width\PYGZus{}height\PYGZus{}depth}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Box}\PYG{o}{.}\PYG{n}{from\PYGZus{}width\PYGZus{}height\PYGZus{}depth}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{T} \PYG{o}{=} \PYG{n}{Translation}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a} \PYG{o}{=} \PYG{n}{Mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}shape}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b} \PYG{o}{=} \PYG{n}{Mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}shape}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}vertices}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{8}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}faces}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}vertices}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{8}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}faces}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{6}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}vertices}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{16}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{a}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}faces}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{12}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.key\_gkey}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.key_gkey:meshplus-key-gkey}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.key_gkey::doc}}\index{key\_gkey() (directional\_clustering.mesh.MeshPlus method)@\spxentry{key\_gkey()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.key_gkey:directional_clustering.mesh.MeshPlus.key_gkey}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{key\_gkey}}}{\emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns a dictionary that maps vertex dictionary keys to the corresponding
\sphinxstyleemphasis{geometric key} up to a certain precision.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{precision} (\sphinxstyleemphasis{str (3f)}) \textendash{} The float precision specifier used in string formatting.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} A dictionary of key\sphinxhyphen{}geometric key pairs.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.key\_index}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.key_index:meshplus-key-index}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.key_index::doc}}\index{key\_index() (directional\_clustering.mesh.MeshPlus method)@\spxentry{key\_index()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.key_index:directional_clustering.mesh.MeshPlus.key_index}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{key\_index}}}{}{}
Returns a dictionary that maps vertex dictionary keys to the
corresponding index in a vertex list or array.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} A dictionary of key\sphinxhyphen{}index pairs.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.normal}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.normal:meshplus-normal}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.normal::doc}}\index{normal() (directional\_clustering.mesh.MeshPlus method)@\spxentry{normal()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.normal:directional_clustering.mesh.MeshPlus.normal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{normal}}}{}{}
Calculate the average mesh normal.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The coordinates of the mesh normal.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.number\_of\_edges}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_edges:meshplus-number-of-edges}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_edges::doc}}\index{number\_of\_edges() (directional\_clustering.mesh.MeshPlus method)@\spxentry{number\_of\_edges()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_edges:directional_clustering.mesh.MeshPlus.number_of_edges}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{number\_of\_edges}}}{}{}
Count the number of edges in the mesh.

\end{fulllineitems}



\subparagraph{MeshPlus.number\_of\_faces}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_faces:meshplus-number-of-faces}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_faces::doc}}\index{number\_of\_faces() (directional\_clustering.mesh.MeshPlus method)@\spxentry{number\_of\_faces()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_faces:directional_clustering.mesh.MeshPlus.number_of_faces}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{number\_of\_faces}}}{}{}
Count the number of faces in the mesh.

\end{fulllineitems}



\subparagraph{MeshPlus.number\_of\_vertices}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_vertices:meshplus-number-of-vertices}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_vertices::doc}}\index{number\_of\_vertices() (directional\_clustering.mesh.MeshPlus method)@\spxentry{number\_of\_vertices()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.number_of_vertices:directional_clustering.mesh.MeshPlus.number_of_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{number\_of\_vertices}}}{}{}
Count the number of vertices in the mesh.

\end{fulllineitems}



\subparagraph{MeshPlus.quads\_to\_triangles}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.quads_to_triangles:meshplus-quads-to-triangles}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.quads_to_triangles::doc}}\index{quads\_to\_triangles() (directional\_clustering.mesh.MeshPlus method)@\spxentry{quads\_to\_triangles()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.quads_to_triangles:directional_clustering.mesh.MeshPlus.quads_to_triangles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{quads\_to\_triangles}}}{\emph{\DUrole{n}{check\_angles}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\end{fulllineitems}



\subparagraph{MeshPlus.remove\_unused\_vertices}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.remove_unused_vertices:meshplus-remove-unused-vertices}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.remove_unused_vertices::doc}}\index{remove\_unused\_vertices() (directional\_clustering.mesh.MeshPlus method)@\spxentry{remove\_unused\_vertices()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.remove_unused_vertices:directional_clustering.mesh.MeshPlus.remove_unused_vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{remove\_unused\_vertices}}}{}{}
Remove all unused vertices from the mesh object.

\end{fulllineitems}



\subparagraph{MeshPlus.smooth\_area}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.smooth_area:meshplus-smooth-area}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.smooth_area::doc}}\index{smooth\_area() (directional\_clustering.mesh.MeshPlus method)@\spxentry{smooth\_area()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.smooth_area:directional_clustering.mesh.MeshPlus.smooth_area}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{smooth\_area}}}{\emph{\DUrole{n}{fixed}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{kmax}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{damping}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{callback}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{callback\_args}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Smooth a mesh by moving each vertex to the barycenter of the centroids of the surrounding faces, weighted by area.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{Mesh}) \textendash{} A mesh object.

\item {} 
\sphinxstylestrong{fixed} (\sphinxstyleemphasis{list, optional}) \textendash{} The fixed vertices of the mesh.

\item {} 
\sphinxstylestrong{kmax} (\sphinxstyleemphasis{int, optional}) \textendash{} The maximum number of iterations.

\item {} 
\sphinxstylestrong{damping} (\sphinxstyleemphasis{float, optional}) \textendash{} The damping factor.

\item {} 
\sphinxstylestrong{callback} (\sphinxstyleemphasis{callable, optional}) \textendash{} A user\sphinxhyphen{}defined callback function to be executed after every iteration.

\item {} 
\sphinxstylestrong{callback\_args} (\sphinxstyleemphasis{list, optional}) \textendash{} A list of arguments to be passed to the callback.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} If a callback is provided, but it is not callable.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.smooth\_centroid}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.smooth_centroid:meshplus-smooth-centroid}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.smooth_centroid::doc}}\index{smooth\_centroid() (directional\_clustering.mesh.MeshPlus method)@\spxentry{smooth\_centroid()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.smooth_centroid:directional_clustering.mesh.MeshPlus.smooth_centroid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{smooth\_centroid}}}{\emph{\DUrole{n}{fixed}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{kmax}\DUrole{o}{=}\DUrole{default_value}{100}}, \emph{\DUrole{n}{damping}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{callback}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{callback\_args}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Smooth a mesh by moving every free vertex to the centroid of its neighbors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{Mesh}) \textendash{} A mesh object.

\item {} 
\sphinxstylestrong{fixed} (\sphinxstyleemphasis{list, optional}) \textendash{} The fixed vertices of the mesh.

\item {} 
\sphinxstylestrong{kmax} (\sphinxstyleemphasis{int, optional}) \textendash{} The maximum number of iterations.

\item {} 
\sphinxstylestrong{damping} (\sphinxstyleemphasis{float, optional}) \textendash{} The damping factor.

\item {} 
\sphinxstylestrong{callback} (\sphinxstyleemphasis{callable, optional}) \textendash{} A user\sphinxhyphen{}defined callback function to be executed after every iteration.

\item {} 
\sphinxstylestrong{callback\_args} (\sphinxstyleemphasis{list, optional}) \textendash{} A list of arguments to be passed to the callback.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} If a callback is provided, but it is not callable.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.split\_edge}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.split_edge:meshplus-split-edge}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.split_edge::doc}}\index{split\_edge() (directional\_clustering.mesh.MeshPlus method)@\spxentry{split\_edge()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.split_edge:directional_clustering.mesh.MeshPlus.split_edge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{split\_edge}}}{\emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}, \emph{\DUrole{n}{t}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{allow\_boundary}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Split and edge by inserting a vertex along its length.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} Instance of a mesh.

\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{str}) \textendash{} The key of the first vertex of the edge.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{str}) \textendash{} The key of the second vertex of the edge.

\item {} 
\sphinxstylestrong{t} (\sphinxstyleemphasis{float (0.5)}) \textendash{} The position of the inserted vertex.
The value should be between 0.0 and 1.0

\item {} 
\sphinxstylestrong{allow\_boundary} (\sphinxstyleemphasis{bool (False)}) \textendash{} Split edges on the boundary.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The key of the inserted vertex.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If u and v are not neighbors.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.split\_face}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.split_face:meshplus-split-face}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.split_face::doc}}\index{split\_face() (directional\_clustering.mesh.MeshPlus method)@\spxentry{split\_face()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.split_face:directional_clustering.mesh.MeshPlus.split_face}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{split\_face}}}{\emph{\DUrole{n}{fkey}}, \emph{\DUrole{n}{u}}, \emph{\DUrole{n}{v}}}{}
Split a face by inserting an edge between two specified vertices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxcode{\sphinxupquote{Mesh}}) \textendash{} Instance of a mesh

\item {} 
\sphinxstylestrong{fkey} (\sphinxcode{\sphinxupquote{str}}) \textendash{} The face key.

\item {} 
\sphinxstylestrong{u} (\sphinxstyleemphasis{hashable}) \textendash{} The key of the first split vertex.

\item {} 
\sphinxstylestrong{v} (\sphinxstyleemphasis{hashable}) \textendash{} The key of the second split vertex.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{tuple}} of \sphinxcode{\sphinxupquote{int}} \textendash{} Keys of the created faces.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If the split vertices does not belong to the split face or if the split
    vertices are neighbors.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{compas}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{compas}\PYG{n+nn}{.}\PYG{n+nn}{datastructures} \PYG{k+kn}{import} \PYG{n}{Mesh}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{Mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}obj}\PYG{p}{(}\PYG{n}{compas}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{faces.obj}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fkey} \PYG{o}{=} \PYG{n}{mesh}\PYG{o}{.}\PYG{n}{get\PYGZus{}any\PYGZus{}face}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} u and v defines the new edge after splitting}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{u} \PYG{o}{=} \PYG{n}{mesh}\PYG{o}{.}\PYG{n}{get\PYGZus{}any\PYGZus{}face\PYGZus{}vertex}\PYG{p}{(}\PYG{n}{fkey}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{v} \PYG{o}{=} \PYG{n}{mesh}\PYG{o}{.}\PYG{n}{face\PYGZus{}vertex\PYGZus{}descendant}\PYG{p}{(}\PYG{n}{fkey}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}faces}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} faces before split}
\PYG{g+go}{25}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh\PYGZus{}split\PYGZus{}face}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{,} \PYG{n}{fkey}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
\PYG{g+go}{(25, 26)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}faces}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} faces after split}
\PYG{g+go}{26}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.summary}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.summary:meshplus-summary}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.summary::doc}}\index{summary() (directional\_clustering.mesh.MeshPlus method)@\spxentry{summary()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.summary:directional_clustering.mesh.MeshPlus.summary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{summary}}}{}{}
Print a summary of the mesh.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{str}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.to\_data}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_data:meshplus-to-data}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_data::doc}}\index{to\_data() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_data()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_data:directional_clustering.mesh.MeshPlus.to_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_data}}}{}{}
Returns a dictionary of structured data representing the data structure.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} The structured data.

\end{description}\end{quote}
\subsubsection*{Notes}

This method produces the data that can be used in conjunction with the
corresponding \sphinxstyleemphasis{from\_data} class method.

\end{fulllineitems}



\subparagraph{MeshPlus.to\_json}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_json:meshplus-to-json}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_json::doc}}\index{to\_json() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_json()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_json:directional_clustering.mesh.MeshPlus.to_json}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_json}}}{\emph{\DUrole{n}{filepath}}, \emph{\DUrole{n}{pretty}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Serialise the structured data representing the datastructure to json.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the json file.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.to\_lines}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_lines:meshplus-to-lines}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_lines::doc}}\index{to\_lines() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_lines()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_lines:directional_clustering.mesh.MeshPlus.to_lines}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_lines}}}{\emph{\DUrole{n}{filepath}}}{}
\end{fulllineitems}



\subparagraph{MeshPlus.to\_obj}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_obj:meshplus-to-obj}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_obj::doc}}\index{to\_obj() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_obj()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_obj:directional_clustering.mesh.MeshPlus.to_obj}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_obj}}}{\emph{\DUrole{n}{filepath}}, \emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{unweld}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Write the mesh to an OBJ file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} Full path of the file.

\item {} 
\sphinxstylestrong{precision} (\sphinxstyleemphasis{str, optional}) \textendash{} The precision of the geometric map that is used to connect the lines.

\item {} 
\sphinxstylestrong{unweld} (\sphinxstyleemphasis{bool, optional}) \textendash{} If true, all faces have their own unique vertices.
If false, vertices are shared between faces if this is also the case in the mesh.
Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
This function only writes geometric data about the vertices and
the faces to the file.
\end{sphinxadmonition}

\end{fulllineitems}



\subparagraph{MeshPlus.to\_off}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_off:meshplus-to-off}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_off::doc}}\index{to\_off() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_off()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_off:directional_clustering.mesh.MeshPlus.to_off}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_off}}}{\emph{\DUrole{n}{filepath}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Write a mesh object to an OFF file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the file.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.to\_ply}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_ply:meshplus-to-ply}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_ply::doc}}\index{to\_ply() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_ply()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_ply:directional_clustering.mesh.MeshPlus.to_ply}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_ply}}}{\emph{\DUrole{n}{filepath}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Write a mesh object to a PLY file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the file.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.to\_points}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_points:meshplus-to-points}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_points::doc}}\index{to\_points() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_points()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_points:directional_clustering.mesh.MeshPlus.to_points}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_points}}}{}{}
\end{fulllineitems}



\subparagraph{MeshPlus.to\_polygons}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_polygons:meshplus-to-polygons}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_polygons::doc}}\index{to\_polygons() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_polygons()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_polygons:directional_clustering.mesh.MeshPlus.to_polygons}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_polygons}}}{}{}
\end{fulllineitems}



\subparagraph{MeshPlus.to\_polylines}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_polylines:meshplus-to-polylines}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_polylines::doc}}\index{to\_polylines() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_polylines()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_polylines:directional_clustering.mesh.MeshPlus.to_polylines}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_polylines}}}{}{}
\end{fulllineitems}



\subparagraph{MeshPlus.to\_quadmesh}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_quadmesh:meshplus-to-quadmesh}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_quadmesh::doc}}\index{to\_quadmesh() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_quadmesh()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_quadmesh:directional_clustering.mesh.MeshPlus.to_quadmesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_quadmesh}}}{}{}
\end{fulllineitems}



\subparagraph{MeshPlus.to\_stl}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_stl:meshplus-to-stl}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_stl::doc}}\index{to\_stl() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_stl()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_stl:directional_clustering.mesh.MeshPlus.to_stl}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_stl}}}{\emph{\DUrole{n}{filepath}}, \emph{\DUrole{n}{precision}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{binary}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
Write a mesh to an STL file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{filepath} (\sphinxstyleemphasis{str}) \textendash{} The path to the file.

\item {} 
\sphinxstylestrong{precision} (\sphinxstyleemphasis{str, optional}) \textendash{} Rounding precision for the vertex coordinates.
Default is \sphinxcode{\sphinxupquote{"3f"}}.

\item {} 
\sphinxstylestrong{binary} (\sphinxstyleemphasis{bool, optional}) \textendash{} When \sphinxcode{\sphinxupquote{False}}, the file will be written in ASCII encoding,
when \sphinxcode{\sphinxupquote{True}}, binary.  Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None}

\end{description}\end{quote}
\subsubsection*{Notes}

STL files only support triangle faces.
It is your responsibility to convert all faces of your mesh to triangles.
For example, with \sphinxcode{\sphinxupquote{compas.datastructures.mesh\_quads\_to\_triangles()}}.

\end{fulllineitems}



\subparagraph{MeshPlus.to\_trimesh}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_trimesh:meshplus-to-trimesh}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_trimesh::doc}}\index{to\_trimesh() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_trimesh()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_trimesh:directional_clustering.mesh.MeshPlus.to_trimesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_trimesh}}}{}{}
\end{fulllineitems}



\subparagraph{MeshPlus.to\_vertices\_and\_faces}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_vertices_and_faces:meshplus-to-vertices-and-faces}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_vertices_and_faces::doc}}\index{to\_vertices\_and\_faces() (directional\_clustering.mesh.MeshPlus method)@\spxentry{to\_vertices\_and\_faces()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.to_vertices_and_faces:directional_clustering.mesh.MeshPlus.to_vertices_and_faces}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{to\_vertices\_and\_faces}}}{}{}
Return the vertices and faces of a mesh.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

\sphinxstyleemphasis{tuple} \textendash{} A 2\sphinxhyphen{}tuple containing
\begin{itemize}
\item {} 
a list of vertices, represented by their XYZ coordinates, and

\item {} 
a list of faces.

\end{itemize}

Each face is a list of indices referencing the list of vertex coordinates.


\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.transform}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transform:meshplus-transform}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transform::doc}}\index{transform() (directional\_clustering.mesh.MeshPlus method)@\spxentry{transform()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transform:directional_clustering.mesh.MeshPlus.transform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{transformation}}}{}
Transform a mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} The mesh.

\item {} 
\sphinxstylestrong{transformation} (\sphinxstyleemphasis{compas.geometry.Transformation}) \textendash{} The transformation.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

The mesh is modified in\sphinxhyphen{}place.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{Mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}obj}\PYG{p}{(}\PYG{n}{compas}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cube.obj}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{T} \PYG{o}{=} \PYG{n}{matrix\PYGZus{}from\PYGZus{}axis\PYGZus{}and\PYGZus{}angle}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tmesh} \PYG{o}{=} \PYG{n}{mesh}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh\PYGZus{}transform}\PYG{p}{(}\PYG{n}{tmesh}\PYG{p}{,} \PYG{n}{T}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.transform\_numpy}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transform_numpy:meshplus-transform-numpy}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transform_numpy::doc}}\index{transform\_numpy() (directional\_clustering.mesh.MeshPlus method)@\spxentry{transform\_numpy()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transform_numpy:directional_clustering.mesh.MeshPlus.transform_numpy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{transform\_numpy}}}{\emph{\DUrole{n}{M}}}{}
\end{fulllineitems}



\subparagraph{MeshPlus.transformed}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transformed:meshplus-transformed}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transformed::doc}}\index{transformed() (directional\_clustering.mesh.MeshPlus method)@\spxentry{transformed()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.transformed:directional_clustering.mesh.MeshPlus.transformed}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{transformed}}}{\emph{\DUrole{n}{transformation}}}{}
Transform a copy of \sphinxcode{\sphinxupquote{mesh}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{compas.datastructures.Mesh}) \textendash{} The mesh.

\item {} 
\sphinxstylestrong{transformation} (\sphinxstyleemphasis{compas.geometry.Transformation}) \textendash{} The transformation.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{Mesh} \textendash{} A transformed independent copy of \sphinxcode{\sphinxupquote{mesh}}.

\end{description}\end{quote}
\subsubsection*{Notes}

The original mesh is not modified.
Instead a transformed independent copy is returned.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mesh} \PYG{o}{=} \PYG{n}{Mesh}\PYG{o}{.}\PYG{n}{from\PYGZus{}obj}\PYG{p}{(}\PYG{n}{compas}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cube.obj}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{T} \PYG{o}{=} \PYG{n}{matrix\PYGZus{}from\PYGZus{}axis\PYGZus{}and\PYGZus{}angle}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{tmesh} \PYG{o}{=} \PYG{n}{mesh\PYGZus{}transformed}\PYG{p}{(}\PYG{n}{mesh}\PYG{p}{,} \PYG{n}{T}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.unify\_cycles}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unify_cycles:meshplus-unify-cycles}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unify_cycles::doc}}\index{unify\_cycles() (directional\_clustering.mesh.MeshPlus method)@\spxentry{unify\_cycles()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unify_cycles:directional_clustering.mesh.MeshPlus.unify_cycles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{unify\_cycles}}}{\emph{\DUrole{n}{root}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Unify the cycle directions of all faces.

Unified cycle directions is a necessary condition for the data structure to
work properly. When in doubt, run this function on your mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{Mesh}) \textendash{} A mesh object.

\item {} 
\sphinxstylestrong{root} (\sphinxstyleemphasis{str, optional {[}None{]}}) \textendash{} The key of the root face.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.unset\_edge\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_edge_attribute:meshplus-unset-edge-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_edge_attribute::doc}}\index{unset\_edge\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{unset\_edge\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_edge_attribute:directional_clustering.mesh.MeshPlus.unset_edge_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{unset\_edge\_attribute}}}{\emph{\DUrole{n}{edge}}, \emph{\DUrole{n}{name}}}{}
Unset the attribute of an edge.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{edge} (\sphinxstyleemphasis{tuple of int}) \textendash{} The edge identifier.

\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the edge does not exist.

\end{description}\end{quote}
\subsubsection*{Notes}

Unsetting the value of an edge attribute implicitly sets it back to the value
stored in the default edge attribute dict.

\end{fulllineitems}



\subparagraph{MeshPlus.unset\_face\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_face_attribute:meshplus-unset-face-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_face_attribute::doc}}\index{unset\_face\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{unset\_face\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_face_attribute:directional_clustering.mesh.MeshPlus.unset_face_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{unset\_face\_attribute}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{name}}}{}
Unset the attribute of a face.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The face identifier.

\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the face does not exist.

\end{description}\end{quote}
\subsubsection*{Notes}

Unsetting the value of a face attribute implicitly sets it back to the value
stored in the default face attribute dict.

\end{fulllineitems}



\subparagraph{MeshPlus.unset\_vertex\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_vertex_attribute:meshplus-unset-vertex-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_vertex_attribute::doc}}\index{unset\_vertex\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{unset\_vertex\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.unset_vertex_attribute:directional_clustering.mesh.MeshPlus.unset_vertex_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{unset\_vertex\_attribute}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{name}}}{}
Unset the attribute of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The vertex identifier.

\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute.

\end{itemize}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the vertex does not exist.

\end{description}\end{quote}
\subsubsection*{Notes}

Unsetting the value of a vertex attribute implicitly sets it back to the value
stored in the default vertex attribute dict.

\end{fulllineitems}



\subparagraph{MeshPlus.update\_default\_edge\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_edge_attributes:meshplus-update-default-edge-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_edge_attributes::doc}}\index{update\_default\_edge\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{update\_default\_edge\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_edge_attributes:directional_clustering.mesh.MeshPlus.update_default_edge_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{update\_default\_edge\_attributes}}}{\emph{\DUrole{n}{attr\_dict}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwattr}}}{}
Update the default edge attributes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{attr\_dict} (\sphinxstyleemphasis{dict, optional}) \textendash{} A dictionary of attributes with their default values.
Defaults to an empty \sphinxcode{\sphinxupquote{dict}}.

\item {} 
\sphinxstylestrong{kwattr} (\sphinxstyleemphasis{dict}) \textendash{} A dictionary compiled of remaining named arguments.
Defaults to an empty dict.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Named arguments overwrite corresponding key\sphinxhyphen{}value pairs in the attribute dictionary,
if they exist.

\end{fulllineitems}



\subparagraph{MeshPlus.update\_default\_face\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_face_attributes:meshplus-update-default-face-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_face_attributes::doc}}\index{update\_default\_face\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{update\_default\_face\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_face_attributes:directional_clustering.mesh.MeshPlus.update_default_face_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{update\_default\_face\_attributes}}}{\emph{\DUrole{n}{attr\_dict}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwattr}}}{}
Update the default face attributes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{attr\_dict} (\sphinxstyleemphasis{dict (None)}) \textendash{} A dictionary of attributes with their default values.

\item {} 
\sphinxstylestrong{kwattr} (\sphinxstyleemphasis{dict}) \textendash{} A dictionary compiled of remaining named arguments.
Defaults to an empty dict.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Named arguments overwrite corresponding key\sphinxhyphen{}value pairs in the attribute dictionary,
if they exist.

\end{fulllineitems}



\subparagraph{MeshPlus.update\_default\_vertex\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_vertex_attributes:meshplus-update-default-vertex-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_vertex_attributes::doc}}\index{update\_default\_vertex\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{update\_default\_vertex\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.update_default_vertex_attributes:directional_clustering.mesh.MeshPlus.update_default_vertex_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{update\_default\_vertex\_attributes}}}{\emph{\DUrole{n}{attr\_dict}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{**}\DUrole{n}{kwattr}}}{}
Update the default vertex attributes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{attr\_dict} (\sphinxstyleemphasis{dict, optional}) \textendash{} A dictionary of attributes with their default values.
Defaults to an empty \sphinxcode{\sphinxupquote{dict}}.

\item {} 
\sphinxstylestrong{kwattr} (\sphinxstyleemphasis{dict}) \textendash{} A dictionary compiled of remaining named arguments.
Defaults to an empty dict.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Named arguments overwrite corresponding key\sphinxhyphen{}value pairs in the attribute dictionary,
if they exist.

\end{fulllineitems}



\subparagraph{MeshPlus.validate\_data}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.validate_data:meshplus-validate-data}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.validate_data::doc}}\index{validate\_data() (directional\_clustering.mesh.MeshPlus method)@\spxentry{validate\_data()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.validate_data:directional_clustering.mesh.MeshPlus.validate_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{validate\_data}}}{}{}
Validate the data of this object against its data schema (\sphinxtitleref{self.DATASCHEMA}).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} The validated data.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{SchemaError}} \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.validate\_json}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.validate_json:meshplus-validate-json}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.validate_json::doc}}\index{validate\_json() (directional\_clustering.mesh.MeshPlus method)@\spxentry{validate\_json()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.validate_json:directional_clustering.mesh.MeshPlus.validate_json}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{validate\_json}}}{}{}
Validate the data loaded from a JSON representation of the data of this object against its data schema (\sphinxtitleref{self.DATASCHEMA}).
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{None}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{SchemaError}} \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_area}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_area:meshplus-vertex-area}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_area::doc}}\index{vertex\_area() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_area()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_area:directional_clustering.mesh.MeshPlus.vertex_area}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_area}}}{\emph{\DUrole{n}{key}}}{}
Compute the tributary area of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The tributary are.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_attribute:meshplus-vertex-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_attribute::doc}}\index{vertex\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_attribute:directional_clustering.mesh.MeshPlus.vertex_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_attribute}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{name}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set an attribute of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The vertex identifier.

\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute

\item {} 
\sphinxstylestrong{value} (\sphinxstyleemphasis{obj, optional}) \textendash{} The value of the attribute.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{object or None} \textendash{} The value of the attribute,
or \sphinxcode{\sphinxupquote{None}} if the vertex does not exist
or when the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the vertex does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_attributes:meshplus-vertex-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_attributes::doc}}\index{vertex\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_attributes:directional_clustering.mesh.MeshPlus.vertex_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_attributes}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{values}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set multiple attributes of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item {} 
\sphinxstylestrong{names} (\sphinxstyleemphasis{list, optional}) \textendash{} A list of attribute names.

\item {} 
\sphinxstylestrong{values} (\sphinxstyleemphasis{list, optional}) \textendash{} A list of attribute values.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict, list or None} \textendash{} If the parameter \sphinxcode{\sphinxupquote{names}} is empty,
the function returns a dictionary of all attribute name\sphinxhyphen{}value pairs of the vertex.
If the parameter \sphinxcode{\sphinxupquote{names}} is not empty,
the function returns a list of the values corresponding to the requested attribute names.
The function returns \sphinxcode{\sphinxupquote{None}} if it is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If the vertex does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_coordinates}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_coordinates:meshplus-vertex-coordinates}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_coordinates::doc}}\index{vertex\_coordinates() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_coordinates()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_coordinates:directional_clustering.mesh.MeshPlus.vertex_coordinates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_coordinates}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{axes}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}xyz\textquotesingle{}}}}{}
Return the coordinates of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item {} 
\sphinxstylestrong{axes} (\sphinxstyleemphasis{str, optional}) \textendash{} The axes along which to take the coordinates.
Should be a combination of \sphinxcode{\sphinxupquote{\textquotesingle{}x\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}y\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}z\textquotesingle{}}}.
Default is \sphinxcode{\sphinxupquote{\textquotesingle{}xyz\textquotesingle{}}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} Coordinates of the vertex.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_curvature}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_curvature:meshplus-vertex-curvature}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_curvature::doc}}\index{vertex\_curvature() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_curvature()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_curvature:directional_clustering.mesh.MeshPlus.vertex_curvature}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_curvature}}}{\emph{\DUrole{n}{vkey}}}{}
Dimensionless vertex curvature.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{fkey} (\sphinxstyleemphasis{int}) \textendash{} The face key.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{float} \textendash{} The dimensionless curvature.

\end{description}\end{quote}
\subsubsection*{References}

Based on %
\begin{footnote}[1]\sphinxAtStartFootnote
Botsch, Mario, et al. \sphinxstyleemphasis{Polygon mesh processing.} AK Peters/CRC Press, 2010.
%
\end{footnote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_degree}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_degree:meshplus-vertex-degree}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_degree::doc}}\index{vertex\_degree() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_degree()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_degree:directional_clustering.mesh.MeshPlus.vertex_degree}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_degree}}}{\emph{\DUrole{n}{key}}}{}
Count the neighbors of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The degree of the vertex.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_faces}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_faces:meshplus-vertex-faces}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_faces::doc}}\index{vertex\_faces() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_faces()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_faces:directional_clustering.mesh.MeshPlus.vertex_faces}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_faces}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{ordered}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{include\_none}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
The faces connected to a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item {} 
\sphinxstylestrong{ordered} (\sphinxstyleemphasis{bool, optional}) \textendash{} Return the faces in cycling order.
Default is \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxstylestrong{include\_none} (\sphinxstyleemphasis{bool, optional}) \textendash{} Include \sphinxstyleemphasis{outside} faces in the list.
Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The faces connected to a vertex.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_index}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_index:meshplus-vertex-index}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_index::doc}}\index{vertex\_index() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_index()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_index:directional_clustering.mesh.MeshPlus.vertex_index}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_index}}}{}{}
Returns a dictionary that maps vertex dictionary keys to the
corresponding index in a vertex list or array.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{dict} \textendash{} A dictionary of key\sphinxhyphen{}index pairs.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_laplacian}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_laplacian:meshplus-vertex-laplacian}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_laplacian::doc}}\index{vertex\_laplacian() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_laplacian()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_laplacian:directional_clustering.mesh.MeshPlus.vertex_laplacian}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_laplacian}}}{\emph{\DUrole{n}{key}}}{}
Compute the vector from a vertex to the centroid of its neighbors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The components of the vector.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_max\_degree}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_max_degree:meshplus-vertex-max-degree}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_max_degree::doc}}\index{vertex\_max\_degree() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_max\_degree()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_max_degree:directional_clustering.mesh.MeshPlus.vertex_max_degree}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_max\_degree}}}{}{}
Compute the maximum degree of all vertices.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The highest degree of all vertices.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_min\_degree}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_min_degree:meshplus-vertex-min-degree}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_min_degree::doc}}\index{vertex\_min\_degree() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_min\_degree()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_min_degree:directional_clustering.mesh.MeshPlus.vertex_min_degree}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_min\_degree}}}{}{}
Compute the minimum degree of all vertices.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{int} \textendash{} The lowest degree of all vertices.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_neighborhood}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighborhood:meshplus-vertex-neighborhood}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighborhood::doc}}\index{vertex\_neighborhood() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_neighborhood()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighborhood:directional_clustering.mesh.MeshPlus.vertex_neighborhood}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_neighborhood}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{ring}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Return the vertices in the neighborhood of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item {} 
\sphinxstylestrong{ring} (\sphinxstyleemphasis{int, optional}) \textendash{} The number of neighborhood rings to include. Default is \sphinxcode{\sphinxupquote{1}}.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The vertices in the neighborhood.

\end{description}\end{quote}
\subsubsection*{Notes}

The vertices in the neighborhood are unordered.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_neighborhood\_centroid}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighborhood_centroid:meshplus-vertex-neighborhood-centroid}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighborhood_centroid::doc}}\index{vertex\_neighborhood\_centroid() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_neighborhood\_centroid()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighborhood_centroid:directional_clustering.mesh.MeshPlus.vertex_neighborhood_centroid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_neighborhood\_centroid}}}{\emph{\DUrole{n}{key}}}{}
Compute the centroid of the neighbors of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The coordinates of the centroid.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_neighbors}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighbors:meshplus-vertex-neighbors}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighbors::doc}}\index{vertex\_neighbors() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_neighbors()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_neighbors:directional_clustering.mesh.MeshPlus.vertex_neighbors}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_neighbors}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{ordered}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Return the neighbors of a vertex.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item {} 
\sphinxstylestrong{ordered} (\sphinxstyleemphasis{bool, optional}) \textendash{} Return the neighbors in the cycling order of the faces.
Default is false.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The list of neighboring vertices.
If the vertex lies on the boundary of the mesh,
an ordered list always starts and ends with with boundary vertices.

\end{description}\end{quote}
\subsubsection*{Notes}

Due to the nature of the ordering algorithm, the neighbors cycle around
the node in the opposite direction as the cycling direction of the faces.
For some algorithms this produces the expected results. For others it doesn’t.
For example, a dual mesh constructed relying on these conventions will have
oposite face cycle directions compared to the original.
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.vertex\_normal}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_normal:meshplus-vertex-normal}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_normal::doc}}\index{vertex\_normal() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertex\_normal()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertex_normal:directional_clustering.mesh.MeshPlus.vertex_normal}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertex\_normal}}}{\emph{\DUrole{n}{key}}}{}
Return the normal vector at the vertex as the weighted average of the
normals of the neighboring faces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{key} (\sphinxstyleemphasis{int}) \textendash{} The identifier of the vertex.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The components of the normal vector.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertices}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices:meshplus-vertices}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices::doc}}\index{vertices() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertices()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices:directional_clustering.mesh.MeshPlus.vertices}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertices}}}{\emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Iterate over the vertices of the mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Return the vertex data as well as the vertex keys.

\item[{Yields}] \leavevmode
\sphinxstyleemphasis{int or tuple} \textendash{} The next vertex identifier, if \sphinxcode{\sphinxupquote{data}} is false.
The next vertex as a (key, attr) tuple, if \sphinxcode{\sphinxupquote{data}} is true.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertices\_attribute}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_attribute:meshplus-vertices-attribute}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_attribute::doc}}\index{vertices\_attribute() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertices\_attribute()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_attribute:directional_clustering.mesh.MeshPlus.vertices_attribute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertices\_attribute}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{keys}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set an attribute of multiple vertices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{name} (\sphinxstyleemphasis{str}) \textendash{} The name of the attribute.

\item {} 
\sphinxstylestrong{value} (\sphinxstyleemphasis{obj, optional}) \textendash{} The value of the attribute.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{keys} (\sphinxstyleemphasis{list of int, optional}) \textendash{} A list of vertex identifiers.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list or None} \textendash{} The value of the attribute for each vertex,
or \sphinxcode{\sphinxupquote{None}} if the function is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If any of the vertices does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertices\_attributes}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_attributes:meshplus-vertices-attributes}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_attributes::doc}}\index{vertices\_attributes() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertices\_attributes()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_attributes:directional_clustering.mesh.MeshPlus.vertices_attributes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertices\_attributes}}}{\emph{\DUrole{n}{names}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{values}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{keys}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get or set multiple attributes of multiple vertices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{names} (\sphinxstyleemphasis{list of str, optional}) \textendash{} The names of the attribute.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{values} (\sphinxstyleemphasis{list of obj, optional}) \textendash{} The values of the attributes.
Default is \sphinxcode{\sphinxupquote{None}}.

\item {} 
\sphinxstylestrong{keys} (\sphinxstyleemphasis{list of int, optional}) \textendash{} A list of vertex identifiers.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list or None} \textendash{} If the parameter \sphinxcode{\sphinxupquote{names}} is \sphinxcode{\sphinxupquote{None}},
the function returns a list containing an attribute dict per vertex.
If the parameter \sphinxcode{\sphinxupquote{names}} is not \sphinxcode{\sphinxupquote{None}},
the function returns a list containing a list of attribute values per vertex corresponding to the provided attribute names.
The function returns \sphinxcode{\sphinxupquote{None}} if it is used as a “setter”.

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{KeyError}} \textendash{} If any of the vertices does not exist.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertices\_on\_boundaries}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_on_boundaries:meshplus-vertices-on-boundaries}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_on_boundaries::doc}}\index{vertices\_on\_boundaries() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertices\_on\_boundaries()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_on_boundaries:directional_clustering.mesh.MeshPlus.vertices_on_boundaries}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertices\_on\_boundaries}}}{}{}
Find the vertices on all boundaries of the mesh.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list of list} \textendash{} A list of vertex keys per boundary.

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.vertices\_on\_boundary}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_on_boundary:meshplus-vertices-on-boundary}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_on_boundary::doc}}\index{vertices\_on\_boundary() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertices\_on\_boundary()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_on_boundary:directional_clustering.mesh.MeshPlus.vertices_on_boundary}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertices\_on\_boundary}}}{\emph{\DUrole{n}{ordered}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Find the vertices on the boundary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{ordered} (\sphinxstyleemphasis{bool, optional}) \textendash{} If \sphinxcode{\sphinxupquote{True}}, Return the vertices in the same order as they are found on the boundary.
Default is \sphinxcode{\sphinxupquote{False}}.

\item[{Returns}] \leavevmode
\sphinxstyleemphasis{list} \textendash{} The vertices of the boundary.

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
If the vertices are requested in order, and the mesh has multiple borders,
currently only the vertices of one of the borders will be returned.
\end{sphinxadmonition}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{MeshPlus.vertices\_where}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_where:meshplus-vertices-where}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_where::doc}}\index{vertices\_where() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertices\_where()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_where:directional_clustering.mesh.MeshPlus.vertices_where}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertices\_where}}}{\emph{\DUrole{n}{conditions}}, \emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Get vertices for which a certain condition or set of conditions is true.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{conditions} (\sphinxstyleemphasis{dict}) \textendash{} A set of conditions in the form of key\sphinxhyphen{}value pairs.
The keys should be attribute names. The values can be attribute
values or ranges of attribute values in the form of min/max pairs.

\item {} 
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Yield the vertices and their data attributes.
Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\item[{Yields}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{hashable}) \textendash{} The next vertex that matches the condition.

\item {} 
\sphinxstyleemphasis{2\sphinxhyphen{}tuple} \textendash{} The next vertex and its attributes, if \sphinxcode{\sphinxupquote{data=True}}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{MeshPlus.vertices\_where\_predicate}
\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_where_predicate:meshplus-vertices-where-predicate}}\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_where_predicate::doc}}\index{vertices\_where\_predicate() (directional\_clustering.mesh.MeshPlus method)@\spxentry{vertices\_where\_predicate()}\spxextra{directional\_clustering.mesh.MeshPlus method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.mesh.MeshPlus.vertices_where_predicate:directional_clustering.mesh.MeshPlus.vertices_where_predicate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{MeshPlus.}}\sphinxbfcode{\sphinxupquote{vertices\_where\_predicate}}}{\emph{\DUrole{n}{predicate}}, \emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Get vertices for which a certain condition or set of conditions is true using a lambda function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{predicate} (\sphinxstyleemphasis{callable}) \textendash{} The condition you want to evaluate. The callable takes 2 parameters: \sphinxcode{\sphinxupquote{key}}, \sphinxcode{\sphinxupquote{attr}} and should return \sphinxcode{\sphinxupquote{True}} or \sphinxcode{\sphinxupquote{False}}.

\item {} 
\sphinxstylestrong{data} (\sphinxstyleemphasis{bool, optional}) \textendash{} Yield the vertices and their data attributes.
Default is \sphinxcode{\sphinxupquote{False}}.

\end{itemize}

\item[{Yields}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{key} (\sphinxstyleemphasis{hashable}) \textendash{} The next vertex that matches the condition.

\item {} 
\sphinxstyleemphasis{2\sphinxhyphen{}tuple} \textendash{} The next vertex and its attributes, if \sphinxcode{\sphinxupquote{data=True}}.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{api/directional_clustering.plotters:module-directional_clustering.plotters}}\index{module@\spxentry{module}!directional\_clustering.plotters@\spxentry{directional\_clustering.plotters}}\index{directional\_clustering.plotters@\spxentry{directional\_clustering.plotters}!module@\spxentry{module}}

\subsection{directional\_clustering.plotters}
\label{\detokenize{api/directional_clustering.plotters:directional-clustering-plotters}}\label{\detokenize{api/directional_clustering.plotters::doc}}

\subsubsection{Classes}
\label{\detokenize{api/directional_clustering.plotters:classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\end{longtable}\sphinxatlongtableend\end{savenotes}
\phantomsection\label{\detokenize{api/directional_clustering.transformations:module-directional_clustering.transformations}}\index{module@\spxentry{module}!directional\_clustering.transformations@\spxentry{directional\_clustering.transformations}}\index{directional\_clustering.transformations@\spxentry{directional\_clustering.transformations}!module@\spxentry{module}}

\subsection{directional\_clustering.transformations}
\label{\detokenize{api/directional_clustering.transformations:directional-clustering-transformations}}\label{\detokenize{api/directional_clustering.transformations::doc}}

\subsubsection{Functions}
\label{\detokenize{api/directional_clustering.transformations:functions}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

{\hyperref[\detokenize{api/generated/directional_clustering.transformations.align_vector_field:directional_clustering.transformations.align_vector_field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{align\_vector\_field}}}}}
&
Aligns vectors to match the orientation of reference vector.
\\
\hline
{\hyperref[\detokenize{api/generated/directional_clustering.transformations.smoothen_vector_field:directional_clustering.transformations.smoothen_vector_field}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{smoothen\_vector\_field}}}}}
&
Apply Laplacian smoothing to a vector field.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{align\_vector\_field}
\label{\detokenize{api/generated/directional_clustering.transformations.align_vector_field:align-vector-field}}\label{\detokenize{api/generated/directional_clustering.transformations.align_vector_field::doc}}\index{align\_vector\_field() (in module directional\_clustering.transformations)@\spxentry{align\_vector\_field()}\spxextra{in module directional\_clustering.transformations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.transformations.align_vector_field:directional_clustering.transformations.align_vector_field}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{directional\_clustering.transformations.}}\sphinxbfcode{\sphinxupquote{align\_vector\_field}}}{\emph{\DUrole{n}{vector\_field}}, \emph{\DUrole{n}{reference\_vector}}}{}
Aligns vectors to match the orientation of reference vector.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{vector\_field} (\sphinxtitleref{directional\_clustering.fields.VectorField}) \textendash{} A vector field.

\item {} 
\sphinxstylestrong{reference\_vector} (\sphinxtitleref{list} of \sphinxtitleref{float}) \textendash{} The vector whose orientation is to be matched.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Comparison made with dot products.
Modifies vector field in place.

\end{fulllineitems}



\paragraph{smoothen\_vector\_field}
\label{\detokenize{api/generated/directional_clustering.transformations.smoothen_vector_field:smoothen-vector-field}}\label{\detokenize{api/generated/directional_clustering.transformations.smoothen_vector_field::doc}}\index{smoothen\_vector\_field() (in module directional\_clustering.transformations)@\spxentry{smoothen\_vector\_field()}\spxextra{in module directional\_clustering.transformations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{api/generated/directional_clustering.transformations.smoothen_vector_field:directional_clustering.transformations.smoothen_vector_field}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{directional\_clustering.transformations.}}\sphinxbfcode{\sphinxupquote{smoothen\_vector\_field}}}{\emph{\DUrole{n}{vector\_field}}, \emph{\DUrole{n}{adjacency}}, \emph{\DUrole{n}{iters}}, \emph{\DUrole{n}{damping}\DUrole{o}{=}\DUrole{default_value}{0.5}}}{}
Apply Laplacian smoothing to a vector field.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{vector\_field} (\sphinxtitleref{directional\_clustering.clustering.VectorField}) \textendash{} A vector field.

\item {} 
\sphinxstylestrong{adjacency} (\sphinxtitleref{dict}) \textendash{} A dictionary that maps a key to all the other keys neighboring it.

\item {} 
\sphinxstylestrong{iters} (\sphinxtitleref{int}) \textendash{} The number of iterations to run this algorithm for.

\item {} 
\sphinxstylestrong{damping} (\sphinxtitleref{float}, optional.) \textendash{} A coefficient between 0.0 and 1.0 that controls the smoothing strength.
1.0 is maximum smoothing.
Defaults to 0.5

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Notes}

Modifies vector field in place.

\end{fulllineitems}



\chapter{License}
\label{\detokenize{license:license}}\label{\detokenize{license::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MIT} \PYG{n}{License}

\PYG{n}{Princeton} \PYG{n}{University}

\PYG{n}{Permission} \PYG{o+ow}{is} \PYG{n}{hereby} \PYG{n}{granted}\PYG{p}{,} \PYG{n}{free} \PYG{n}{of} \PYG{n}{charge}\PYG{p}{,} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{person} \PYG{n}{obtaining} \PYG{n}{a} \PYG{n}{copy}
\PYG{n}{of} \PYG{n}{this} \PYG{n}{software} \PYG{o+ow}{and} \PYG{n}{associated} \PYG{n}{documentation} \PYG{n}{files} \PYG{p}{(}\PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Software}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{to} \PYG{n}{deal}
\PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{Software} \PYG{n}{without} \PYG{n}{restriction}\PYG{p}{,} \PYG{n}{including} \PYG{n}{without} \PYG{n}{limitation} \PYG{n}{the} \PYG{n}{rights}
\PYG{n}{to} \PYG{n}{use}\PYG{p}{,} \PYG{n}{copy}\PYG{p}{,} \PYG{n}{modify}\PYG{p}{,} \PYG{n}{merge}\PYG{p}{,} \PYG{n}{publish}\PYG{p}{,} \PYG{n}{distribute}\PYG{p}{,} \PYG{n}{sublicense}\PYG{p}{,} \PYG{o+ow}{and}\PYG{o}{/}\PYG{o+ow}{or} \PYG{n}{sell}
\PYG{n}{copies} \PYG{n}{of} \PYG{n}{the} \PYG{n}{Software}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{to} \PYG{n}{permit} \PYG{n}{persons} \PYG{n}{to} \PYG{n}{whom} \PYG{n}{the} \PYG{n}{Software} \PYG{o+ow}{is}
\PYG{n}{furnished} \PYG{n}{to} \PYG{n}{do} \PYG{n}{so}\PYG{p}{,} \PYG{n}{subject} \PYG{n}{to} \PYG{n}{the} \PYG{n}{following} \PYG{n}{conditions}\PYG{p}{:}

\PYG{n}{The} \PYG{n}{above} \PYG{n}{copyright} \PYG{n}{notice} \PYG{o+ow}{and} \PYG{n}{this} \PYG{n}{permission} \PYG{n}{notice} \PYG{n}{shall} \PYG{n}{be} \PYG{n}{included} \PYG{o+ow}{in} \PYG{n+nb}{all}
\PYG{n}{copies} \PYG{o+ow}{or} \PYG{n}{substantial} \PYG{n}{portions} \PYG{n}{of} \PYG{n}{the} \PYG{n}{Software}\PYG{o}{.}

\PYG{n}{THE} \PYG{n}{SOFTWARE} \PYG{n}{IS} \PYG{n}{PROVIDED} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AS IS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{WITHOUT} \PYG{n}{WARRANTY} \PYG{n}{OF} \PYG{n}{ANY} \PYG{n}{KIND}\PYG{p}{,} \PYG{n}{EXPRESS} \PYG{n}{OR}
\PYG{n}{IMPLIED}\PYG{p}{,} \PYG{n}{INCLUDING} \PYG{n}{BUT} \PYG{n}{NOT} \PYG{n}{LIMITED} \PYG{n}{TO} \PYG{n}{THE} \PYG{n}{WARRANTIES} \PYG{n}{OF} \PYG{n}{MERCHANTABILITY}\PYG{p}{,}
\PYG{n}{FITNESS} \PYG{n}{FOR} \PYG{n}{A} \PYG{n}{PARTICULAR} \PYG{n}{PURPOSE} \PYG{n}{AND} \PYG{n}{NONINFRINGEMENT}\PYG{o}{.} \PYG{n}{IN} \PYG{n}{NO} \PYG{n}{EVENT} \PYG{n}{SHALL} \PYG{n}{THE}
\PYG{n}{AUTHORS} \PYG{n}{OR} \PYG{n}{COPYRIGHT} \PYG{n}{HOLDERS} \PYG{n}{BE} \PYG{n}{LIABLE} \PYG{n}{FOR} \PYG{n}{ANY} \PYG{n}{CLAIM}\PYG{p}{,} \PYG{n}{DAMAGES} \PYG{n}{OR} \PYG{n}{OTHER}
\PYG{n}{LIABILITY}\PYG{p}{,} \PYG{n}{WHETHER} \PYG{n}{IN} \PYG{n}{AN} \PYG{n}{ACTION} \PYG{n}{OF} \PYG{n}{CONTRACT}\PYG{p}{,} \PYG{n}{TORT} \PYG{n}{OR} \PYG{n}{OTHERWISE}\PYG{p}{,} \PYG{n}{ARISING} \PYG{n}{FROM}\PYG{p}{,}
\PYG{n}{OUT} \PYG{n}{OF} \PYG{n}{OR} \PYG{n}{IN} \PYG{n}{CONNECTION} \PYG{n}{WITH} \PYG{n}{THE} \PYG{n}{SOFTWARE} \PYG{n}{OR} \PYG{n}{THE} \PYG{n}{USE} \PYG{n}{OR} \PYG{n}{OTHER} \PYG{n}{DEALINGS} \PYG{n}{IN} \PYG{n}{THE}
\PYG{n}{SOFTWARE}\PYG{o}{.}
\end{sphinxVerbatim}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{directional\_clustering}\sphinxstyleindexpageref{api/directional_clustering:\detokenize{module-directional_clustering}}
\item\relax\sphinxstyleindexentry{directional\_clustering.clustering}\sphinxstyleindexpageref{api/directional_clustering.clustering:\detokenize{module-directional_clustering.clustering}}
\item\relax\sphinxstyleindexentry{directional\_clustering.fields}\sphinxstyleindexpageref{api/directional_clustering.fields:\detokenize{module-directional_clustering.fields}}
\item\relax\sphinxstyleindexentry{directional\_clustering.mesh}\sphinxstyleindexpageref{api/directional_clustering.mesh:\detokenize{module-directional_clustering.mesh}}
\item\relax\sphinxstyleindexentry{directional\_clustering.plotters}\sphinxstyleindexpageref{api/directional_clustering.plotters:\detokenize{module-directional_clustering.plotters}}
\item\relax\sphinxstyleindexentry{directional\_clustering.transformations}\sphinxstyleindexpageref{api/directional_clustering.transformations:\detokenize{module-directional_clustering.transformations}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}